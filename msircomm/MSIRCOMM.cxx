/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2014 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int __stdcall IrCommWmi(int, PIRP Irp); // idb
NTSTATUS __stdcall IrCommAddDevice(PDRIVER_OBJECT DriverObject, PDEVICE_OBJECT TargetDevice);
NTSTATUS __stdcall IrCommPnP(PDEVICE_OBJECT DeviceObject, PIRP Irp);
NTSTATUS __stdcall IrCommPower(int a1, PIRP Irp);
int __stdcall IoCompletionSetEvent(int, int, PRKEVENT Event); // idb
NTSTATUS __stdcall GetRegistryKeyValue(PDEVICE_OBJECT DeviceObject, ULONG DevInstKeyType, PCWSTR SourceString, int a4, void *a5, int a6);
NTSTATUS __stdcall IrCommHandleSymbolicLink(PDEVICE_OBJECT DeviceObject, PUNICODE_STRING SymbolicLinkName, char a3);
NTSTATUS __stdcall ForwardIrp(PDEVICE_OBJECT DeviceObject, PIRP Irp);
NTSTATUS __stdcall QueryPdoInformation(PDEVICE_OBJECT DeviceObject, int a2, int a3, int a4);
int __stdcall IrCommCreate(int, PIRP Irp); // idb
int __stdcall IrCommClose(int, PIRP Irp); // idb
void __stdcall CleanupIoRequests(int NewIrql);
int __stdcall IrCommCleanup(int, PIRP Irp); // idb
int __stdcall IrCommQueryInformation(int, PIRP Irp); // idb
int __stdcall IrCommWrite(int, PIRP Irp); // idb
void __stdcall SendComplete(int a1, PIRP Irp);
void __stdcall WriteStartRoutine(int NewIrql, int a2);
void __stdcall IrpQueueCancelRoutine(int a1, PIRP Irp);
int __stdcall GetUseableIrp(int a1);
void __stdcall QueuePacket(int NewIrql, PIRP Irp, char a3);
void __stdcall StartNextPacket(int NewIrql);
void __stdcall FlushQueuedPackets(int NewIrql, char a2);
char __stdcall CopyMemoryAndCheckForChar(unsigned int a1, int a2, int a3, char a4);
void __stdcall SeeIfIrpShouldBeCompleted(int NewIrql);
void __stdcall ReadPurge(int NewIrql, int a2);
int __stdcall IrCommRead(int, PIRP Irp); // idb
void __stdcall MoveDataFromBufferToIrp(int NewIrql);
void __stdcall ReadCancelRoutine(int a1, int a2);
void __stdcall IntervalTimeProc(struct _KDPC *Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2);
void __stdcall TotalTimerProc(struct _KDPC *Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2);
void __stdcall ReadStartRoutine(KIRQL Irql, int NewIrql);
int __stdcall DataAvailibleHandler(int a1, int a2, int a3, int NewIrql);
void __stdcall LockedMemoryCopy(PKSPIN_LOCK SpinLock, void *a2, void *a3, size_t a4);
void __stdcall UartComplete(int a1, PIRP Irp);
int __stdcall IrCommDeviceControl(int, PIRP Irp); // idb
void __stdcall UartStartRoutine(int a1, int a2);
void __stdcall WaitMaskCancelRoutine(int a1, PIRP Irp);
int __stdcall GetCurrentWaitIrp(int a1);
void __stdcall MaskStartRoutine(int NewIrql, PIRP Irp);
void __stdcall EventNotification(int NewIrql, int a2);
// void *__cdecl memset(void *, int, size_t);
// void *__cdecl memcpy(void *, const void *, size_t);
// ULONG DbgPrint(PCH Format, ...);
NTSTATUS __stdcall IrdaCreateAddress(const void *a1, HANDLE *a2);
NTSTATUS __stdcall IrdaCreateConnection(HANDLE *a1, int a2);
NTSTATUS __stdcall IrdaDisconnect(PFILE_OBJECT FileObject);
NTSTATUS __stdcall IrdaAssociateAddress(PFILE_OBJECT FileObject, int a2);
PVOID __stdcall IrdaCreateConnectionForAddress(int a1, int a2, int a3, PVOID Object);
LONG __stdcall RemoveReferenceOnLink(LONG a1);
PKSPIN_LOCK __stdcall GetCurrentConnection(PKSPIN_LOCK SpinLock);
void *__stdcall ConnectionGetFileObject(int a1);
LONG_PTR __stdcall ConnectionReleaseFileObject(int a1, PVOID Object);
PSINGLE_LIST_ENTRY __stdcall ConnectionGetBuffer(int a1, int a2);
int __stdcall IrdaRestartDeviceControl(int a1, int a2, int a3);
NTSTATUS __stdcall IrdaIssueDeviceControl(HANDLE Handle, PVOID Object, void *a3, size_t a4, PVOID VirtualAddress, ULONG Length, char a7);
NTSTATUS __stdcall IrdaSetEventHandler(PVOID Object, int a2, int a3, int a4);
int __stdcall ClientEventReceive(LONG a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
NTSTATUS __stdcall GetMaxSendPdu(PFILE_OBJECT FileObject, PVOID OutputBuffer);
void __stdcall ConnectionPassiveWorkRoutine(PKSPIN_LOCK SpinLock);
void __stdcall RemoveReferenceFromConnection(PKSPIN_LOCK SpinLock);
LONG __stdcall RemoveRefTdiObjects(LONG a1);
void __stdcall CloseTdiObjects(PVOID P);
HRESULT __stdcall StringCbCopyA(STRSAFE_LPSTR pszDest, size_t cbDest, STRSAFE_LPCSTR pszSrc);
NTSTATUS __stdcall InitiateConnection(struct _FILE_OBJECT *a1, int a2, STRSAFE_LPCSTR pszSrc);
void __stdcall CloseTdiLink(PKSPIN_LOCK SpinLock);
void __stdcall ReleaseConnection(PKSPIN_LOCK SpinLock);
int __stdcall LinkEventDisconnect(PKSPIN_LOCK SpinLock, int, int, int, int, int, int); // idb
int __stdcall IrdaCompleteAcceptIrp(int, PIRP Irp, PKSPIN_LOCK SpinLock); // idb
PVOID __stdcall OpenTdiObjects(STRSAFE_LPCSTR pszSrc, char a2);
int __stdcall LinkEventConnect(PKSPIN_LOCK SpinLock, int, int, int, int, int, int, int, int); // idb
signed int __stdcall CreateTdiLink(int a1, int a2, const char *a3, char a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11);
void __stdcall RemoveReferenceOnBufferPool(PVOID P);
void __stdcall FreeBufferPool(PVOID P);
PSINGLE_LIST_ENTRY __stdcall GetBuffer(PVOID P);
void __stdcall FreeBuffer(PSINGLE_LIST_ENTRY ListEntry);
PVOID __stdcall CreateBufferPool(CCHAR StackSize, ULONG Length, int a3);
NTSTATUS __stdcall IrdaIASOctetSet(PFILE_OBJECT FileObject, int pszSrc, int a3, int a4, size_t a5);
LONG __stdcall RemoveRefereneToConnection(volatile LONG *Addend);
int __stdcall HandleControlInformation(int a1, unsigned int a2, int a3);
signed int __stdcall LinkReceiveHandler(int a1, int a2, unsigned int a3, int a4, int a5, int *a6, int a7);
void __stdcall LinkStateHandler(int a1, int a2, int a3);
void __stdcall FreeConnection(PVOID P);
signed int __stdcall ReceiveCompletion(int a1, int a2, int a3);
int __stdcall IndicateReceiveBufferSpaceAvailible(int a1);
signed int __stdcall IrdaConnect(int a1, int a2, const char *a3, char a4, int a5, int a6, int a7, int a8);
void __stdcall RemoveReferenceOnTracker(volatile LONG *Addend);
int __stdcall GetCurrentIrpAndAddReference(int a1);
void __stdcall ReleaseIrpReference(volatile LONG *Addend);
int __stdcall SetIrpAndRefcounts(int a1, int a2);
void __stdcall TryToCompleteCurrentIrp(int NewIrql);
NTSTATUS __stdcall SendBufferToTdi(PFILE_OBJECT FileObject, int a2);
void __stdcall AbortSend(int a1);
void __stdcall SendTimerProc(struct _KDPC *Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2);
void __stdcall SendCancelRoutine(int a1, int a2);
void __stdcall ProcessSend(int NewIrql);
void __stdcall ProcessSendAtPassive(int NewIrql);
void __stdcall SendWorkItemRountine(int NewIrql);
signed int __stdcall SendCompletion(int a1, int a2, int a3);
void __stdcall SendOnConnection(volatile LONG *Addend, int a2, int a3, int NewIrql, int a5);
LONG __stdcall UartStateCompletion(volatile LONG *Addend, int a2);
signed int __stdcall SendControlIrpCompletionRoutine(int a1, int a2, int a3);
LONG_PTR __stdcall SendControlInfo(int a1, int a2, int a3, char a4, char a5, void *a6);
LONG __stdcall SetEventCompletion(PRKEVENT Event, int a2);
int __stdcall SendSynchronousControlInfo(int, char, char, void *); // idb
void __stdcall AccessUartState(volatile LONG *Addend, int a2, int a3, int a4);
void __cdecl __report_gsfailure();
// LONG __fastcall InterlockedExchangeAdd(volatile LONG *Addend, LONG Increment);
// KIRQL __stdcall KeGetCurrentIrql();
// KIRQL __fastcall KfAcquireSpinLock(PKSPIN_LOCK SpinLock);
// void __fastcall KfReleaseSpinLock(PKSPIN_LOCK SpinLock, KIRQL NewIrql);
// PVOID __stdcall ExAllocatePoolWithTag(POOL_TYPE PoolType, SIZE_T NumberOfBytes, ULONG Tag);
// void __fastcall IofCompleteRequest(PIRP Irp, CCHAR PriorityBoost);
// void __stdcall IoDeleteDevice(PDEVICE_OBJECT DeviceObject);
// void __stdcall IoDetachDevice(PDEVICE_OBJECT TargetDevice);
// void __stdcall KeInitializeDpc(PRKDPC Dpc, PKDEFERRED_ROUTINE DeferredRoutine, PVOID DeferredContext);
// void __stdcall KeInitializeTimer(PKTIMER Timer);
// PDEVICE_OBJECT __stdcall IoAttachDeviceToDeviceStack(PDEVICE_OBJECT SourceDevice, PDEVICE_OBJECT TargetDevice);
// NTSTATUS __stdcall IoCreateDevice(PDRIVER_OBJECT DriverObject, ULONG DeviceExtensionSize, PUNICODE_STRING DeviceName, ULONG DeviceType, ULONG DeviceCharacteristics, BOOLEAN Exclusive, PDEVICE_OBJECT *DeviceObject);
// NTSTATUS __fastcall IofCallDriver(PDEVICE_OBJECT DeviceObject, PIRP Irp);
// NTSTATUS __stdcall PoCallDriver(PDEVICE_OBJECT DeviceObject, PIRP Irp);
// void __stdcall PoStartNextPowerIrp(PIRP Irp);
// LONG __stdcall KeSetEvent(PRKEVENT Event, KPRIORITY Increment, BOOLEAN Wait);
// NTSTATUS __stdcall ZwClose(HANDLE Handle);
// NTSTATUS __stdcall ZwQueryValueKey(HANDLE KeyHandle, PUNICODE_STRING ValueName, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);
// void __stdcall RtlInitUnicodeString(PUNICODE_STRING DestinationString, PCWSTR SourceString);
// NTSTATUS __stdcall IoOpenDeviceRegistryKey(PDEVICE_OBJECT DeviceObject, ULONG DevInstKeyType, ACCESS_MASK DesiredAccess, PHANDLE DevInstRegKey);
// NTSTATUS __stdcall IoDeleteSymbolicLink(PUNICODE_STRING SymbolicLinkName);
// NTSTATUS __stdcall RtlQueryRegistryValues(ULONG RelativeTo, PCWSTR Path, PRTL_QUERY_REGISTRY_TABLE QueryTable, PVOID Context, PVOID Environment);
// void __stdcall RtlFreeUnicodeString(PUNICODE_STRING UnicodeString);
// NTSTATUS __stdcall IoSetDeviceInterfaceState(PUNICODE_STRING SymbolicLinkName, BOOLEAN Enable);
// NTSTATUS __stdcall IoRegisterDeviceInterface(PDEVICE_OBJECT PhysicalDeviceObject, const GUID *InterfaceClassGuid, PUNICODE_STRING ReferenceString, PUNICODE_STRING SymbolicLinkName);
// NTSTATUS __stdcall RtlWriteRegistryValue(ULONG RelativeTo, PCWSTR Path, PCWSTR ValueName, ULONG ValueType, PVOID ValueData, ULONG ValueLength);
// NTSTATUS __stdcall IoCreateSymbolicLink(PUNICODE_STRING SymbolicLinkName, PUNICODE_STRING DeviceName);
// NTSTATUS __stdcall IoGetDeviceProperty(PDEVICE_OBJECT DeviceObject, DEVICE_REGISTRY_PROPERTY DeviceProperty, ULONG BufferLength, PVOID PropertyBuffer, PULONG ResultLength);
// NTSTATUS __stdcall RtlAppendUnicodeToString(PUNICODE_STRING Destination, PCWSTR Source);
// NTSTATUS __stdcall KeWaitForSingleObject(PVOID Object, KWAIT_REASON WaitReason, KPROCESSOR_MODE WaitMode, BOOLEAN Alertable, PLARGE_INTEGER Timeout);
// void __stdcall KeInitializeEvent(PRKEVENT Event, EVENT_TYPE Type, BOOLEAN State);
// void __stdcall IoFreeIrp(PIRP Irp);
// PIRP __stdcall IoAllocateIrp(CCHAR StackSize, BOOLEAN ChargeQuota);
// void __stdcall IoReleaseCancelSpinLock(KIRQL Irql);
// void __stdcall IoAcquireCancelSpinLock(PKIRQL Irql);
// BOOLEAN __stdcall KeCancelTimer(PKTIMER);
// BOOLEAN __stdcall KeSetTimer(PKTIMER Timer, LARGE_INTEGER DueTime, PKDPC Dpc);
// PVOID __stdcall MmLockPagableDataSection(PVOID AddressWithinSection);
// void __stdcall MmUnlockPagableImageSection(PVOID ImageSectionHandle);
// NTSTATUS __stdcall RtlDeleteRegistryValue(ULONG RelativeTo, PCWSTR Path, PCWSTR ValueName);
// PKTHREAD __stdcall KeGetCurrentThread();
// NTSTATUS __stdcall ObReferenceObjectByHandle(HANDLE Handle, ACCESS_MASK DesiredAccess, POBJECT_TYPE ObjectType, KPROCESSOR_MODE AccessMode, PVOID *Object, POBJECT_HANDLE_INFORMATION HandleInformation);
// NTSTATUS __stdcall ZwCreateFile(PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength);
// PIRP __stdcall IoBuildDeviceIoControlRequest(ULONG IoControlCode, PDEVICE_OBJECT DeviceObject, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength, BOOLEAN InternalDeviceIoControl, PKEVENT Event, PIO_STATUS_BLOCK IoStatusBlock);
// PDEVICE_OBJECT __stdcall IoGetRelatedDeviceObject(PFILE_OBJECT FileObject);
// LONG_PTR __fastcall ObfDereferenceObject(PVOID Object);
// LONG_PTR __fastcall ObfReferenceObject(PVOID Object);
// void __stdcall IoFreeMdl(PMDL Mdl);
// int __stdcall IoEnqueueIrp(_DWORD); weak
// void __stdcall MmBuildMdlForNonPagedPool(PMDL MemoryDescriptorList);
// PMDL __stdcall IoAllocateMdl(PVOID VirtualAddress, ULONG Length, BOOLEAN SecondaryBuffer, BOOLEAN ChargeQuota, PIRP Irp);
// LONG __stdcall KeResetEvent(PRKEVENT Event);
// void __stdcall ExQueueWorkItem(PWORK_QUEUE_ITEM WorkItem, WORK_QUEUE_TYPE QueueType);
// PSINGLE_LIST_ENTRY __fastcall InterlockedPopEntrySList(PSLIST_HEADER ListHead);
// PSINGLE_LIST_ENTRY __fastcall InterlockedPushEntrySList(PSLIST_HEADER ListHead, PSINGLE_LIST_ENTRY ListEntry);
// LONG __fastcall InterlockedDecrement(volatile LONG *Addend);
// void __stdcall IoReuseIrp(PIRP Irp, NTSTATUS Iostatus);
// LONG __fastcall InterlockedExchange(volatile LONG *Target, LONG Value);
// LONG __fastcall InterlockedIncrement(volatile LONG *Addend);
// void __stdcall KeBugCheckEx(ULONG BugCheckCode, ULONG_PTR BugCheckParameter1, ULONG_PTR BugCheckParameter2, ULONG_PTR BugCheckParameter3, ULONG_PTR BugCheckParameter4);
// void __stdcall ExFreePoolWithTag(PVOID P, ULONG Tag);
int __stdcall IrCommUnload(int); // weak
NTSTATUS __stdcall WaitForLowerDriverToCompleteIrp(PDEVICE_OBJECT DeviceObject, PIRP Irp, char a3);
void __stdcall InitializePacketQueue(void *a1, int a2, int a3);
NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath);
void __cdecl __security_init_cookie();
NTSTATUS __stdcall GsDriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath);

//-------------------------------------------------------------------------
// Data declarations

char aTransportaddre[17] = "TransportAddress"; // weak
// extern volatile KSYSTEM_TIME _KeTickCount;
GUID GUID_DEVINTERFACE_COMPORT = { 2262880736u, 32905u, 4560u, { 156u, 228u, 8u, 0u, 62u, 48u, 31u, 115u } };
ULONG DebugMemoryTag = 1866691145u; // idb
ULONG_PTR __security_cookie = 3141592654u; // idb
ULONG_PTR __security_cookie_complement = 1153374641u; // idb
int PagedCodeSectionHandle = 0; // weak


//----- (00011006) --------------------------------------------------------
int __stdcall IrCommWmi(int a1, PIRP Irp)
{
  IofCompleteRequest(Irp, 0);
  return 0;
}

//----- (00011022) --------------------------------------------------------
NTSTATUS __stdcall IrCommAddDevice(PDRIVER_OBJECT DriverObject, PDEVICE_OBJECT TargetDevice)
{
  NTSTATUS result; // eax@1
  int v3; // esi@2
  PDEVICE_OBJECT v4; // edi@2
  struct _DEVICE_OBJECT *v5; // ST0C_4@3
  struct _DEVICE_OBJECT *v6; // ST00_4@3
  PVOID v7; // eax@5
  struct _DEVICE_OBJECT *v8; // esi@8
  PDEVICE_OBJECT DeviceObject; // [sp+8h] [bp-4h]@1

  DeviceObject = 0;
  result = IoCreateDevice(DriverObject, 0x2188u, 0, 0x15u, 0x80u, 0, &DeviceObject);
  if ( result >= 0 )
  {
    v3 = (int)DeviceObject->DeviceExtension;
    v4 = IoAttachDeviceToDeviceStack(DeviceObject, TargetDevice);
    if ( !v4 )
      goto LABEL_14;
    DeviceObject->Flags |= 0x2004u;
    DeviceObject->Flags &= 0xFFFFFF7F;
    DeviceObject->StackSize = v4->StackSize + 1;
    memset((void *)v3, 0, 0x2188u);
    *(_DWORD *)v3 = DeviceObject;
    *(_DWORD *)(v3 + 4) = TargetDevice;
    *(_DWORD *)(v3 + 8) = v4;
    KeInitializeTimer((PKTIMER)(v3 + 312));
    KeInitializeDpc((PRKDPC)(v3 + 352), IntervalTimeProc, (PVOID)v3);
    KeInitializeTimer((PKTIMER)(v3 + 392));
    KeInitializeDpc((PRKDPC)(v3 + 432), TotalTimerProc, (PVOID)v3);
    v5 = TargetDevice;
    *(_DWORD *)(v3 + 40) = 0;
    *(_DWORD *)(v3 + 468) = 0;
    *(_DWORD *)(v3 + 204) = 0;
    IrCommHandleSymbolicLink(v5, (PUNICODE_STRING)(v3 + 28), 1);
    v6 = TargetDevice;
    *(_BYTE *)(v3 + 18) = 1;
    if ( GetRegistryKeyValue(v6, 2u, L"ListenForIncommingConnections", 4, &DriverObject, 4) >= 0 )
      *(_BYTE *)(v3 + 18) = DriverObject == 0;
    v7 = OpenTdiObjects("IrDA:IrCOMM", *(_BYTE *)(v3 + 18));
    *(_DWORD *)(v3 + 12) = v7;
    if ( v7 )
    {
      InitializePacketQueue((void *)(v3 + 100), v3, (int)WriteStartRoutine);
      InitializePacketQueue((void *)(v3 + 256), v3, (int)ReadStartRoutine);
      InitializePacketQueue((void *)(v3 + 148), v3, (int)MaskStartRoutine);
      InitializePacketQueue((void *)(v3 + 208), v3, (int)UartStartRoutine);
      *(_DWORD *)(v3 + 472) = 0;
      *(_DWORD *)(v3 + 476) = v3 + 492;
      *(_DWORD *)(v3 + 480) = v3 + 492;
      result = 0;
    }
    else
    {
LABEL_14:
      if ( *(_DWORD *)(v3 + 32) )
        IrCommHandleSymbolicLink(*(PDEVICE_OBJECT *)(v3 + 4), (PUNICODE_STRING)(v3 + 28), 0);
      v8 = *(struct _DEVICE_OBJECT **)(v3 + 8);
      if ( v8 )
        IoDetachDevice(v8);
      IoDeleteDevice(DeviceObject);
      result = -1073741670;
    }
  }
  return result;
}

//----- (000111DE) --------------------------------------------------------
NTSTATUS __stdcall IrCommPnP(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
  PVOID v2; // ebx@1
  signed int v3; // eax@1
  int v4; // eax@4
  int v5; // eax@5
  struct _IRP::$::$::$::$A02EC6A2CE86544F716F4825015773AC::_IO_STACK_LOCATION *v6; // esi@12
  NTSTATUS v7; // esi@12
  int v9; // eax@13
  int v10; // eax@14
  int v11; // ST08_4@16

  v2 = DeviceObject->DeviceExtension;
  v3 = *(_BYTE *)(Irp->Tail.Overlay.PacketType + 1);
  if ( v3 > 4 )
  {
    v9 = v3 - 5;
    if ( v9 )
    {
      v10 = v9 - 1;
      if ( v10 )
      {
        if ( v10 != 17 )
          return ForwardIrp(*((PDEVICE_OBJECT *)v2 + 2), Irp);
        v11 = (int)DeviceObject->DeviceExtension;
        *((_BYTE *)v2 + 16) = 1;
        CleanupIoRequests(v11);
      }
    }
LABEL_17:
    Irp->IoStatus.Status = 0;
    return ForwardIrp(*((PDEVICE_OBJECT *)v2 + 2), Irp);
  }
  if ( v3 == 4 )
    goto LABEL_17;
  if ( !*(_BYTE *)(Irp->Tail.Overlay.PacketType + 1) )
    goto LABEL_7;
  v4 = v3 - 1;
  if ( !v4 )
    goto LABEL_7;
  v5 = v4 - 1;
  if ( v5 )
  {
    if ( v5 != 1 )
      return ForwardIrp(*((PDEVICE_OBJECT *)v2 + 2), Irp);
LABEL_7:
    Irp->IoStatus.Status = 0;
    return ForwardIrp(*((PDEVICE_OBJECT *)v2 + 2), Irp);
  }
  *((_BYTE *)v2 + 16) = 1;
  *((_BYTE *)v2 + 17) = 1;
  if ( *((_DWORD *)v2 + 8) )
    IrCommHandleSymbolicLink(*((PDEVICE_OBJECT *)v2 + 1), (PUNICODE_STRING)((char *)v2 + 28), 0);
  if ( *((_DWORD *)v2 + 3) )
    CloseTdiObjects(*((PVOID *)v2 + 3));
  v6 = Irp->Tail.Overlay.CurrentStackLocation;
  qmemcpy((char *)v6 - 36, (const void *)v6, 0x1Cu);
  *((_BYTE *)v6 - 33) = 0;
  v7 = IofCallDriver(*((PDEVICE_OBJECT *)v2 + 2), Irp);
  IoDetachDevice(*((PDEVICE_OBJECT *)v2 + 2));
  IoDeleteDevice(DeviceObject);
  return v7;
}

//----- (000112A2) --------------------------------------------------------
NTSTATUS __stdcall IrCommPower(int a1, PIRP Irp)
{
  PIRP v2; // esi@1
  int v3; // edi@1

  v2 = Irp;
  v3 = *(_DWORD *)(a1 + 40);
  PoStartNextPowerIrp(Irp);
  ++v2->CurrentLocation;
  v2->Tail.Overlay.PacketType += 36;
  return PoCallDriver(*(PDEVICE_OBJECT *)(v3 + 8), Irp);
}

//----- (000112D6) --------------------------------------------------------
int __stdcall IoCompletionSetEvent(int a1, int a2, PRKEVENT Event)
{
  KeSetEvent(Event, 0, 0);
  return -1073741802;
}

//----- (000112F6) --------------------------------------------------------
NTSTATUS __stdcall GetRegistryKeyValue(PDEVICE_OBJECT DeviceObject, ULONG DevInstKeyType, PCWSTR SourceString, int a4, void *a5, int a6)
{
  NTSTATUS v6; // ebx@1
  int v7; // edi@2
  PVOID v8; // esi@2
  UNICODE_STRING DestinationString; // [sp+4h] [bp-8h]@2

  v6 = IoOpenDeviceRegistryKey(DeviceObject, DevInstKeyType, 0x20000u, (PHANDLE)&DeviceObject);
  if ( v6 >= 0 )
  {
    RtlInitUnicodeString(&DestinationString, SourceString);
    v7 = a6;
    DevInstKeyType = a6 + 16;
    v8 = ExAllocatePoolWithTag(PagedPool, a6 + 16, DebugMemoryTag);
    if ( v8 )
    {
      v6 = ZwQueryValueKey(
             DeviceObject,
             &DestinationString,
             KeyValuePartialInformation,
             v8,
             DevInstKeyType,
             &DevInstKeyType);
      if ( v6 >= 0 )
      {
        if ( a4 == *((_DWORD *)v8 + 1) )
        {
          if ( (unsigned int)v7 < *((_DWORD *)v8 + 2) )
            v6 = -1073741789;
          else
            memcpy(a5, (char *)v8 + 12, *((_DWORD *)v8 + 2));
        }
        else
        {
          v6 = -1073741788;
        }
      }
      ExFreePoolWithTag(v8, 0);
    }
    else
    {
      v6 = -1073741670;
    }
    ZwClose(DeviceObject);
  }
  return v6;
}

//----- (000113BC) --------------------------------------------------------
NTSTATUS __stdcall IrCommHandleSymbolicLink(PDEVICE_OBJECT DeviceObject, PUNICODE_STRING SymbolicLinkName, char a3)
{
  WCHAR *v3; // eax@1
  NTSTATUS result; // eax@2
  WCHAR *v5; // eax@4
  UNICODE_STRING DeviceName; // [sp+Ch] [bp-18h]@1
  UNICODE_STRING Destination; // [sp+14h] [bp-10h]@1
  ULONG ResultLength; // [sp+1Ch] [bp-8h]@6
  NTSTATUS v9; // [sp+20h] [bp-4h]@3

  DeviceName.Buffer = 0;
  Destination.Length = 0;
  Destination.MaximumLength = 512;
  v3 = (WCHAR *)ExAllocatePoolWithTag(PagedPool, 0x202u, DebugMemoryTag);
  Destination.Buffer = v3;
  if ( v3 )
  {
    memset(v3, 0, Destination.MaximumLength + 2);
    RtlAppendUnicodeToString(&Destination, L"\\DosDevices\\");
    v9 = GetRegistryKeyValue(
           DeviceObject,
           1u,
           L"PortName",
           1,
           &Destination.Buffer[(unsigned int)Destination.Length >> 1],
           Destination.MaximumLength - Destination.Length);
    if ( v9 >= 0 )
    {
      Destination.Length = 2 * wcslen(Destination.Buffer);
      DeviceName.Length = 0;
      DeviceName.MaximumLength = 512;
      v5 = (WCHAR *)ExAllocatePoolWithTag(PagedPool, 0x202u, DebugMemoryTag);
      DeviceName.Buffer = v5;
      if ( v5 )
      {
        v9 = IoGetDeviceProperty(
               DeviceObject,
               DevicePropertyPhysicalDeviceObjectName,
               DeviceName.MaximumLength,
               v5,
               &ResultLength);
        if ( v9 >= 0 )
        {
          DeviceName.Length += ResultLength - 2;
          if ( a3 )
          {
            if ( IoCreateSymbolicLink(&Destination, &DeviceName) >= 0 )
              RtlWriteRegistryValue(
                4u,
                L"SERIALCOMM",
                DeviceName.Buffer,
                1u,
                Destination.Buffer + 12,
                Destination.Length - 24);
            v9 = IoRegisterDeviceInterface(DeviceObject, &GUID_DEVINTERFACE_COMPORT, 0, SymbolicLinkName);
            if ( v9 >= 0 )
              IoSetDeviceInterfaceState(SymbolicLinkName, 1u);
          }
          else
          {
            if ( SymbolicLinkName->Buffer )
            {
              IoSetDeviceInterfaceState(SymbolicLinkName, 0);
              RtlFreeUnicodeString(SymbolicLinkName);
            }
            RtlDeleteRegistryValue(4u, L"SERIALCOMM", DeviceName.Buffer);
            v9 = IoDeleteSymbolicLink(&Destination);
          }
        }
      }
      else
      {
        v9 = -1073741670;
      }
    }
    if ( Destination.Buffer )
    {
      ExFreePoolWithTag(Destination.Buffer, 0);
      Destination.Buffer = 0;
    }
    if ( DeviceName.Buffer )
      ExFreePoolWithTag(DeviceName.Buffer, 0);
    result = v9;
  }
  else
  {
    result = -1073741670;
  }
  return result;
}

//----- (0001158C) --------------------------------------------------------
NTSTATUS __stdcall ForwardIrp(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
  PIRP v2; // edx@1

  v2 = Irp;
  ++v2->CurrentLocation;
  v2->Tail.Overlay.PacketType += 36;
  return IofCallDriver(DeviceObject, Irp);
}

//----- (000115AE) --------------------------------------------------------
NTSTATUS __stdcall QueryPdoInformation(PDEVICE_OBJECT DeviceObject, int a2, int a3, int a4)
{
  PDEVICE_OBJECT i; // edi@1
  PIRP v5; // eax@4
  PIRP v6; // esi@4
  NTSTATUS result; // eax@5
  struct _IRP::$::$::$::$A02EC6A2CE86544F716F4825015773AC::_IO_STACK_LOCATION *v8; // eax@6
  NTSTATUS v9; // edi@6

  for ( i = DeviceObject; i->AttachedDevice; i = i->AttachedDevice )
    ;
  v5 = IoAllocateIrp(i->StackSize + 1, 0);
  v6 = v5;
  if ( v5 )
  {
    v8 = v5->Tail.Overlay.CurrentStackLocation;
    v6->IoStatus.Information = 0;
    v8 = (struct _IRP::$::$::$::$A02EC6A2CE86544F716F4825015773AC::_IO_STACK_LOCATION *)((char *)v8 - 36);
    v6->IoStatus.Status = -1073741637;
    *((_DWORD *)v8 + 3) = 0;
    *((_DWORD *)v8 + 1) = a2;
    *((_DWORD *)v8 + 2) = a3;
    *(_BYTE *)v8 = 27;
    *((_BYTE *)v8 + 1) = 15;
    *((_DWORD *)v8 + 4) = a4;
    v9 = WaitForLowerDriverToCompleteIrp(i, v6, 0);
    IoFreeIrp(v6);
    result = v9;
  }
  else
  {
    result = -1073741670;
  }
  return result;
}

//----- (0001162E) --------------------------------------------------------
int __stdcall IrCommCreate(int a1, PIRP Irp)
{
  int v2; // esi@1
  volatile signed __int32 *v3; // ebx@1
  struct _IRP *v4; // ecx@2
  signed int v5; // edi@2
  int v7; // [sp+Ch] [bp-8h]@4

  v2 = *(_DWORD *)(a1 + 40);
  v3 = (volatile signed __int32 *)(v2 + 20);
  if ( _InterlockedIncrement((volatile signed __int32 *)(v2 + 20)) <= 1 )
  {
    v5 = QueryPdoInformation(*(PDEVICE_OBJECT *)(v2 + 4), 0, (int)&v7, 8);
    if ( v5 < 0
      || (*(_DWORD *)(v2 + 36) = v7,
          v5 = IrdaConnect(
                 *(_DWORD *)(v2 + 12),
                 v7,
                 "IrDA:IrCOMM",
                 *(_BYTE *)(v2 + 18),
                 v2 + 24,
                 (int)DataAvailibleHandler,
                 (int)EventNotification,
                 v2),
          v5 < 0) )
    {
      if ( *(_DWORD *)(v2 + 24) )
      {
        FreeConnection(*(PVOID *)(v2 + 24));
        *(_DWORD *)(v2 + 24) = 0;
      }
      _InterlockedExchangeAdd(v3, 0xFFFFFFFF);
    }
    else
    {
      *(_DWORD *)(v2 + 80) = 9;
      *(_DWORD *)(v2 + 84) = 128;
    }
    v4 = Irp;
    Irp->IoStatus.Status = v5;
  }
  else
  {
    _InterlockedExchangeAdd(v3, 0xFFFFFFFF);
    v4 = Irp;
    Irp->IoStatus.Status = -1073741790;
    v5 = -1073741790;
  }
  IofCompleteRequest(v4, 0);
  return v5;
}

//----- (000116F0) --------------------------------------------------------
int __stdcall IrCommClose(int a1, PIRP Irp)
{
  int v2; // esi@1

  v2 = *(_DWORD *)(a1 + 40);
  FreeConnection(*(PVOID *)(v2 + 24));
  *(_DWORD *)(v2 + 24) = 0;
  _InterlockedExchangeAdd((volatile signed __int32 *)(v2 + 20), 0xFFFFFFFF);
  Irp->IoStatus.Status = 0;
  IofCompleteRequest(Irp, 0);
  return 0;
}

//----- (0001172E) --------------------------------------------------------
void __stdcall CleanupIoRequests(int NewIrql)
{
  KIRQL v1; // al@1
  int v2; // esi@1

  FlushQueuedPackets(NewIrql + 100, -1);
  FlushQueuedPackets(NewIrql + 256, -1);
  ReadPurge(NewIrql, 0);
  FlushQueuedPackets(NewIrql + 148, -1);
  FlushQueuedPackets(NewIrql + 208, -1);
  v1 = KfAcquireSpinLock((PKSPIN_LOCK)(NewIrql + 204));
  v2 = *(_DWORD *)(NewIrql + 200);
  *(_DWORD *)(NewIrql + 200) = 0;
  KfReleaseSpinLock((PKSPIN_LOCK)(NewIrql + 204), v1);
  if ( v2 )
  {
    *(_DWORD *)(v2 + 28) = 0;
    *(_DWORD *)(v2 + 24) = -1073741536;
    IofCompleteRequest((PIRP)v2, 0);
  }
}

//----- (000117BE) --------------------------------------------------------
int __stdcall IrCommCleanup(int a1, PIRP Irp)
{
  CleanupIoRequests(*(_DWORD *)(a1 + 40));
  Irp->IoStatus.Status = 0;
  IofCompleteRequest(Irp, 0);
  return 0;
}

//----- (000117E8) --------------------------------------------------------
int __stdcall IrCommQueryInformation(int a1, PIRP Irp)
{
  Irp->IoStatus.Status = 0;
  Irp->IoStatus.Information = 0;
  IofCompleteRequest(Irp, 0);
  return 0;
}

//----- (0001180C) --------------------------------------------------------
int __stdcall IrCommWrite(int a1, PIRP Irp)
{
  int v2; // ecx@1
  int result; // eax@2

  v2 = *(_DWORD *)(a1 + 40);
  if ( *(_BYTE *)(v2 + 16) )
  {
    Irp->IoStatus.Status = -1073741130;
    IofCompleteRequest(Irp, 0);
    result = -1073741130;
  }
  else
  {
    *(_BYTE *)(Irp->Tail.Overlay.PacketType + 3) |= 1u;
    QueuePacket(v2 + 100, Irp, 0);
    result = 259;
  }
  return result;
}

//----- (0001185A) --------------------------------------------------------
void __stdcall SendComplete(int a1, PIRP Irp)
{
  if ( *(_BYTE *)Irp->Tail.Overlay.CurrentStackLocation == 4 )
    _InterlockedExchangeAdd((volatile signed __int32 *)(a1 + 144), Irp->IoStatus.Information);
  IofCompleteRequest(Irp, 0);
  StartNextPacket(a1 + 100);
}

//----- (00011896) --------------------------------------------------------
void __stdcall WriteStartRoutine(int NewIrql, int a2)
{
  SendOnConnection(
    *(volatile LONG **)(NewIrql + 24),
    a2,
    (int)SendComplete,
    NewIrql,
    *(_DWORD *)(NewIrql + 60) + *(_DWORD *)(NewIrql + 56) * *(_DWORD *)(*(_DWORD *)(a2 + 96) + 4));
}

//----- (000118C8) --------------------------------------------------------
void __stdcall IrpQueueCancelRoutine(int a1, PIRP Irp)
{
  KSPIN_LOCK *v2; // ebx@1
  KIRQL v3; // al@1

  IoReleaseCancelSpinLock(Irp->CancelIrql);
  v2 = (KSPIN_LOCK *)&Irp->Tail.Overlay.DeviceQueueEntry.DeviceListEntry.Flink[2];
  v3 = KfAcquireSpinLock(v2);
  if ( Irp->Tail.Overlay.ListEntry.Flink )
    RemoveEntryList((struct _LIST_ENTRY *)&Irp->Tail.CompletionKey + 3);
  KfReleaseSpinLock(v2, v3);
  Irp->IoStatus.Information = 0;
  Irp->IoStatus.Status = -1073741536;
  IofCompleteRequest(Irp, 0);
}

//----- (00011928) --------------------------------------------------------
int __stdcall GetUseableIrp(int a1)
{
  int result; // eax@1
  int v2; // eax@3
  int v3; // edx@3

  result = 0;
  do
  {
    if ( *(_DWORD *)a1 == a1 )
      break;
    v2 = *(_DWORD *)(a1 + 4);
    v3 = *(_DWORD *)(v2 + 4);
    *(_DWORD *)(a1 + 4) = v3;
    result = v2 - 88;
    *(_DWORD *)v3 = a1;
    if ( !_InterlockedExchange((volatile signed __int32 *)(result + 56), 0) )
    {
      *(_DWORD *)(result + 88) = 0;
      result = 0;
    }
  }
  while ( !result );
  return result;
}

//----- (00011964) --------------------------------------------------------
void __stdcall QueuePacket(int NewIrql, PIRP Irp, char a3)
{
  int v3; // esi@1
  KSPIN_LOCK *v4; // ebx@1
  KIRQL v5; // dl@1
  char *v6; // eax@9
  struct _LIST_ENTRY *v7; // ecx@10
  int v8; // ecx@11
  KIRQL Irql[4]; // [sp+Fh] [bp-5h]@5
  char v10; // [sp+13h] [bp-1h]@1
  KIRQL v11; // [sp+1Fh] [bp+Bh]@1

  v3 = NewIrql;
  v4 = (KSPIN_LOCK *)(NewIrql + 16);
  v10 = 0;
  v5 = KfAcquireSpinLock((PKSPIN_LOCK)(NewIrql + 16));
  v11 = v5;
  if ( *(_DWORD *)(v3 + 8) || !*(_BYTE *)(v3 + 12) || *(_DWORD *)v3 != v3 )
  {
    Irp->Tail.Overlay.DeviceQueueEntry.DeviceListEntry.Flink = (struct _LIST_ENTRY *)v3;
    IoAcquireCancelSpinLock(Irql);
    if ( Irp->Cancel )
      v10 = 1;
    else
      _InterlockedExchange((volatile signed __int32 *)&Irp->CancelRoutine, (signed __int32)IrpQueueCancelRoutine);
    IoReleaseCancelSpinLock(Irql[0]);
    if ( !v10 )
    {
      v6 = (char *)(&Irp->Tail.CompletionKey + 6);
      if ( a3 )
      {
        v7 = *(struct _LIST_ENTRY **)(v3 + 4);
        *(_DWORD *)v6 = v3;
        Irp->Tail.Overlay.ListEntry.Blink = v7;
        v7->Flink = (struct _LIST_ENTRY *)v6;
        *(_DWORD *)(v3 + 4) = v6;
      }
      else
      {
        v8 = *(_DWORD *)v3;
        *(_DWORD *)v6 = *(_DWORD *)v3;
        Irp->Tail.Overlay.ListEntry.Blink = (struct _LIST_ENTRY *)v3;
        *(_DWORD *)(v8 + 4) = v6;
        *(_DWORD *)v3 = v6;
      }
    }
    KfReleaseSpinLock(v4, v11);
    if ( v10 )
    {
      Irp->IoStatus.Information = 0;
      Irp->IoStatus.Status = -1073741536;
      IofCompleteRequest(Irp, 0);
    }
  }
  else
  {
    *(_DWORD *)(v3 + 8) = Irp;
    KfReleaseSpinLock(v4, v5);
    (*(void (__stdcall **)(_DWORD, PIRP))(v3 + 24))(*(_DWORD *)(v3 + 20), Irp);
  }
}

//----- (00011A38) --------------------------------------------------------
void __stdcall StartNextPacket(int NewIrql)
{
  int v1; // esi@1
  KIRQL v2; // al@1
  bool v3; // zf@3
  int v4; // eax@4
  int v5; // ebx@4
  KSPIN_LOCK *SpinLock; // [sp+8h] [bp-4h]@1
  KIRQL v7; // [sp+17h] [bp+Bh]@1

  v1 = NewIrql;
  SpinLock = (KSPIN_LOCK *)(NewIrql + 16);
  v2 = KfAcquireSpinLock((PKSPIN_LOCK)(NewIrql + 16));
  *(_DWORD *)(NewIrql + 8) = 0;
  v7 = v2;
  if ( !*(_BYTE *)(v1 + 13) )
  {
    *(_BYTE *)(v1 + 13) = 1;
    while ( 1 )
    {
      v3 = *(_BYTE *)(v1 + 12) == 0;
      if ( !*(_BYTE *)(v1 + 12) )
        break;
      v4 = GetUseableIrp(v1);
      v5 = v4;
      if ( v4 )
      {
        *(_DWORD *)(v1 + 8) = v4;
        KfReleaseSpinLock(SpinLock, v7);
        (*(void (__stdcall **)(_DWORD, int))(v1 + 24))(*(_DWORD *)(v1 + 20), v5);
        v7 = KfAcquireSpinLock(SpinLock);
        if ( !*(_DWORD *)(v1 + 8) )
          continue;
      }
      v3 = *(_BYTE *)(v1 + 12) == 0;
      break;
    }
    if ( v3 && !*(_DWORD *)(v1 + 8) )
      KeSetEvent((PRKEVENT)(v1 + 28), 0, 0);
    *(_BYTE *)(v1 + 13) = 0;
  }
  KfReleaseSpinLock(SpinLock, v7);
}

//----- (00011ACE) --------------------------------------------------------
void __stdcall FlushQueuedPackets(int NewIrql, char a2)
{
  int v2; // edi@1
  KSPIN_LOCK *v3; // ecx@1
  int *v4; // ecx@4
  int v5; // eax@4
  int v6; // esi@7
  int *v7; // eax@9
  int v8; // ecx@9
  int v9; // edx@9
  int *v10; // [sp+Ch] [bp-Ch]@1
  int *v11; // [sp+10h] [bp-8h]@1
  PKSPIN_LOCK SpinLock; // [sp+14h] [bp-4h]@1
  KIRQL v13; // [sp+23h] [bp+Bh]@6

  v2 = NewIrql;
  v3 = (KSPIN_LOCK *)(NewIrql + 16);
  v11 = (int *)&v10;
  v10 = (int *)&v10;
  SpinLock = (PKSPIN_LOCK)(NewIrql + 16);
LABEL_6:
  v13 = KfAcquireSpinLock(v3);
  while ( 1 )
  {
    v6 = GetUseableIrp(v2);
    if ( !v6 )
      break;
    if ( a2 == -1 || a2 == **(_BYTE **)(v6 + 96) )
    {
      KfReleaseSpinLock(SpinLock, v13);
      *(_DWORD *)(v6 + 28) = 0;
      *(_DWORD *)(v6 + 24) = -1073741536;
      IofCompleteRequest((PIRP)v6, 0);
      v3 = SpinLock;
      goto LABEL_6;
    }
    v4 = v10;
    v5 = v6 + 88;
    *(_DWORD *)v5 = v10;
    *(_DWORD *)(v5 + 4) = &v10;
    v4[1] = v6 + 88;
    v10 = (int *)(v6 + 88);
  }
  while ( (int **)v10 != &v10 )
  {
    v7 = v11;
    v8 = (int)(v11 + 1);
    v11 = (int *)v11[1];
    *v11 = (int)&v10;
    v9 = *(_DWORD *)v2;
    *v7 = *(_DWORD *)v2;
    *(_DWORD *)v8 = v2;
    *(_DWORD *)(v9 + 4) = v7;
    *(_DWORD *)v2 = v7;
  }
  KfReleaseSpinLock(SpinLock, v13);
}

//----- (00011B8A) --------------------------------------------------------
char __stdcall CopyMemoryAndCheckForChar(unsigned int a1, int a2, int a3, char a4)
{
  unsigned int v4; // ecx@1
  char result; // al@1
  int v6; // esi@2
  char v7; // dl@3

  v4 = a1;
  result = 0;
  if ( a1 < a1 + a3 )
  {
    v6 = a2;
    do
    {
      v7 = *(_BYTE *)v6;
      *(_BYTE *)v4 = *(_BYTE *)v6;
      if ( v7 == a4 )
        result = 1;
      ++v4;
      ++v6;
    }
    while ( v4 < a1 + a3 );
  }
  return result;
}

//----- (00011BC0) --------------------------------------------------------
void __stdcall SeeIfIrpShouldBeCompleted(int NewIrql)
{
  int v1; // esi@1
  int v2; // eax@12
  struct _IRP *Irp; // [sp+8h] [bp-4h]@1
  KIRQL v4; // [sp+17h] [bp+Bh]@1

  v1 = NewIrql;
  Irp = 0;
  v4 = KfAcquireSpinLock((PKSPIN_LOCK)(NewIrql + 468));
  if ( *(_DWORD *)(v1 + 300) && *(_BYTE *)(v1 + 308) )
  {
    if ( *(_BYTE *)(v1 + 384) && KeCancelTimer((PKTIMER)(v1 + 312)) )
    {
      --*(_DWORD *)(v1 + 304);
      *(_BYTE *)(v1 + 384) = 0;
    }
    if ( *(_BYTE *)(v1 + 464) && KeCancelTimer((PKTIMER)(v1 + 392)) )
    {
      --*(_DWORD *)(v1 + 304);
      *(_BYTE *)(v1 + 464) = 0;
    }
    if ( _InterlockedExchange((volatile signed __int32 *)(*(_DWORD *)(v1 + 300) + 56), 0) )
      --*(_DWORD *)(v1 + 304);
    if ( *(_DWORD *)(v1 + 304) == 1 )
    {
      Irp = *(struct _IRP **)(v1 + 300);
      v2 = *(_DWORD *)(v1 + 300);
      *(_DWORD *)(v1 + 300) = 0;
      _InterlockedExchangeAdd((volatile signed __int32 *)(v1 + 484), *(_DWORD *)(v2 + 28));
    }
  }
  KfReleaseSpinLock((PKSPIN_LOCK)(v1 + 468), v4);
  if ( Irp )
  {
    IofCompleteRequest(Irp, 0);
    StartNextPacket(v1 + 256);
  }
}

//----- (00011CB2) --------------------------------------------------------
void __stdcall ReadPurge(int NewIrql, int a2)
{
  int v2; // esi@1
  KIRQL v3; // al@2
  bool v4; // zf@2
  char v5; // [sp+7h] [bp-1h]@1
  KIRQL v6; // [sp+13h] [bp+Bh]@2

  v2 = NewIrql;
  v5 = 0;
  if ( !a2 )
  {
    v3 = KfAcquireSpinLock((PKSPIN_LOCK)(NewIrql + 468));
    *(_DWORD *)(NewIrql + 472) = 0;
    v6 = v3;
    v4 = *(_BYTE *)(v2 + 310) == 0;
    *(_DWORD *)(v2 + 476) = v2 + 492;
    *(_DWORD *)(v2 + 480) = v2 + 492;
    if ( !v4 )
    {
      DbgPrint("IRCOMM: requesting data from purge\n");
      *(_BYTE *)(v2 + 310) = 0;
      v5 = 1;
    }
    KfReleaseSpinLock((PKSPIN_LOCK)(v2 + 468), v6);
  }
  if ( a2 == 1 )
  {
    *(_BYTE *)(v2 + 308) = 1;
    SeeIfIrpShouldBeCompleted(v2);
  }
  if ( v5 )
    IndicateReceiveBufferSpaceAvailible(*(_DWORD *)(v2 + 24));
}

//----- (00011D48) --------------------------------------------------------
int __stdcall IrCommRead(int a1, PIRP Irp)
{
  int v2; // edx@1
  int result; // eax@2

  v2 = *(_DWORD *)(a1 + 40);
  if ( *(_BYTE *)(v2 + 16) )
  {
    Irp->IoStatus.Status = -1073741130;
    IofCompleteRequest(Irp, 0);
    result = -1073741130;
  }
  else
  {
    *(_BYTE *)(Irp->Tail.Overlay.PacketType + 3) |= 1u;
    Irp->IoStatus.Information = 0;
    QueuePacket(v2 + 256, Irp, 0);
    result = 259;
  }
  return result;
}

//----- (00011D9A) --------------------------------------------------------
void __stdcall MoveDataFromBufferToIrp(int NewIrql)
{
  int v1; // esi@1
  KIRQL v2; // al@1
  int v3; // edi@1
  int v4; // eax@2
  int v5; // edx@2
  int v6; // eax@2
  const void *v7; // eax@4
  size_t v8; // ebx@4
  size_t v9; // ebx@6
  int v10; // [sp+8h] [bp-Ch]@2
  int v11; // [sp+Ch] [bp-8h]@2
  char v12; // [sp+13h] [bp-1h]@1
  KIRQL v13; // [sp+1Fh] [bp+Bh]@1

  v1 = NewIrql;
  v12 = 0;
  v2 = KfAcquireSpinLock((PKSPIN_LOCK)(NewIrql + 468));
  v3 = *(_DWORD *)(NewIrql + 300);
  v13 = v2;
  if ( v3 )
  {
    v4 = *(_DWORD *)(v3 + 96);
    v5 = *(_DWORD *)(v3 + 28);
    v10 = v4;
    v6 = *(_DWORD *)(v4 + 4) - v5;
    v11 = *(_DWORD *)(v1 + 472);
    if ( v11 >= (unsigned int)v6 )
      v11 = v6;
    v7 = *(const void **)(v1 + 476);
    v8 = v1 - (_DWORD)v7 + 8584;
    if ( v11 < v8 )
      v8 = v11;
    memcpy((void *)(v5 + *(_DWORD *)(v3 + 12)), v7, v8);
    *(_DWORD *)(v1 + 476) += v8;
    *(_DWORD *)(v1 + 472) -= v8;
    *(_DWORD *)(v3 + 28) += v8;
    v9 = v11 - v8;
    if ( v9 )
    {
      *(_DWORD *)(v1 + 476) = v1 + 492;
      memcpy((void *)(*(_DWORD *)(v3 + 28) + *(_DWORD *)(v3 + 12)), (const void *)(v1 + 492), v9);
      *(_DWORD *)(v1 + 476) += v9;
      *(_DWORD *)(v1 + 472) -= v9;
      *(_DWORD *)(v3 + 28) += v9;
    }
    if ( *(_DWORD *)(v3 + 28) == *(_DWORD *)(v10 + 4) )
    {
      *(_DWORD *)(v3 + 24) = 0;
      *(_BYTE *)(v1 + 308) = 1;
    }
    if ( *(_BYTE *)(v1 + 309) && *(_DWORD *)(v3 + 28) )
    {
      *(_DWORD *)(v3 + 24) = 0;
      *(_BYTE *)(v1 + 308) = 1;
    }
  }
  if ( !*(_DWORD *)(v1 + 472) && *(_BYTE *)(v1 + 310) )
  {
    DbgPrint("IRCOMM: requesting data\n");
    *(_BYTE *)(v1 + 310) = 0;
    v12 = 1;
  }
  KfReleaseSpinLock((PKSPIN_LOCK)(v1 + 468), v13);
  if ( v12 )
    IndicateReceiveBufferSpaceAvailible(*(_DWORD *)(v1 + 24));
}

//----- (00011ED2) --------------------------------------------------------
void __stdcall ReadCancelRoutine(int a1, int a2)
{
  int v2; // esi@1
  KIRQL v3; // al@1

  v2 = *(_DWORD *)(a1 + 40);
  IoReleaseCancelSpinLock(*(_BYTE *)(a2 + 37));
  v3 = KfAcquireSpinLock((PKSPIN_LOCK)(v2 + 468));
  --*(_DWORD *)(v2 + 304);
  *(_BYTE *)(v2 + 308) = 1;
  KfReleaseSpinLock((PKSPIN_LOCK)(v2 + 468), v3);
  SeeIfIrpShouldBeCompleted(v2);
}

//----- (00011F24) --------------------------------------------------------
void __stdcall IntervalTimeProc(struct _KDPC *Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2)
{
  KIRQL v4; // al@1

  MoveDataFromBufferToIrp((int)DeferredContext);
  v4 = KfAcquireSpinLock((PKSPIN_LOCK)DeferredContext + 117);
  --*((_DWORD *)DeferredContext + 76);
  *((_BYTE *)DeferredContext + 384) = 0;
  *((_BYTE *)DeferredContext + 308) = 1;
  KfReleaseSpinLock((PKSPIN_LOCK)DeferredContext + 117, v4);
  SeeIfIrpShouldBeCompleted((int)DeferredContext);
}

//----- (00011F72) --------------------------------------------------------
void __stdcall TotalTimerProc(struct _KDPC *Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2)
{
  KIRQL v4; // al@1

  MoveDataFromBufferToIrp((int)DeferredContext);
  v4 = KfAcquireSpinLock((PKSPIN_LOCK)DeferredContext + 117);
  --*((_DWORD *)DeferredContext + 76);
  *((_BYTE *)DeferredContext + 464) = 0;
  *((_BYTE *)DeferredContext + 308) = 1;
  KfReleaseSpinLock((PKSPIN_LOCK)DeferredContext + 117, v4);
  SeeIfIrpShouldBeCompleted((int)DeferredContext);
}

//----- (00011FC0) --------------------------------------------------------
void __stdcall ReadStartRoutine(KIRQL Irql, int NewIrql)
{
  int v2; // esi@1
  int v3; // edi@1
  KSPIN_LOCK *v4; // ecx@1
  int v5; // eax@7
  int v6; // ecx@13
  int v7; // [sp+Ch] [bp-4h]@1

  v2 = Irql;
  v3 = NewIrql;
  v4 = (KSPIN_LOCK *)(Irql + 468);
  v7 = *(_DWORD *)(NewIrql + 96);
  *(_DWORD *)(NewIrql + 28) = 0;
  *(_DWORD *)(v3 + 24) = 258;
  BYTE3(NewIrql) = KfAcquireSpinLock(v4);
  *(_DWORD *)(v2 + 304) = 1;
  *(_DWORD *)(v2 + 300) = v3;
  *(_BYTE *)(v2 + 308) = 0;
  *(_BYTE *)(v2 + 309) = 0;
  IoAcquireCancelSpinLock(&Irql);
  if ( *(_BYTE *)(v3 + 36) )
    *(_BYTE *)(v2 + 308) = 0;
  ++*(_DWORD *)(v2 + 304);
  _InterlockedExchange((volatile signed __int32 *)(v3 + 56), (signed __int32)ReadCancelRoutine);
  IoReleaseCancelSpinLock(Irql);
  if ( *(_DWORD *)(v2 + 44) == -1 && !*(_DWORD *)(v2 + 48) && !*(_DWORD *)(v2 + 52) )
  {
    *(_BYTE *)(v2 + 308) = 1;
    *(_DWORD *)(v3 + 24) = 0;
  }
  v5 = *(_DWORD *)(v2 + 48);
  if ( v5 || *(_DWORD *)(v2 + 52) )
  {
    if ( v5 == -1 && *(_DWORD *)(v2 + 44) == -1 )
    {
      *(_BYTE *)(v2 + 309) = 1;
      v5 = 0;
    }
    KeSetTimer(
      (PKTIMER)(v2 + 392),
      (LARGE_INTEGER)(-10000i64 * (unsigned int)(*(_DWORD *)(v2 + 52) + v5 * *(_DWORD *)(v7 + 4))),
      (PKDPC)(v2 + 432));
    ++*(_DWORD *)(v2 + 304);
    *(_BYTE *)(v2 + 464) = 1;
  }
  v6 = *(_DWORD *)(v2 + 44);
  *(_DWORD *)(v2 + 488) = 0;
  if ( v6 && v6 != -1 )
    *(_DWORD *)(v2 + 488) = v6;
  KfReleaseSpinLock((PKSPIN_LOCK)(v2 + 468), BYTE3(NewIrql));
  MoveDataFromBufferToIrp(v2);
  SeeIfIrpShouldBeCompleted(v2);
}

//----- (000120EE) --------------------------------------------------------
int __stdcall DataAvailibleHandler(int a1, int a2, int a3, int NewIrql)
{
  int v4; // ebx@1
  int v5; // esi@1
  KSPIN_LOCK *v6; // edi@1
  KIRQL v7; // dl@1
  int v8; // eax@1
  unsigned int v9; // eax@3
  int v10; // edi@3
  char v11; // al@5
  int v12; // eax@5
  char v13; // ST0C_1@6
  unsigned int v14; // eax@11
  bool v15; // bl@14
  signed int v16; // eax@16
  char v18; // [sp+Fh] [bp-1h]@1
  int v19; // [sp+18h] [bp+8h]@2
  int v20; // [sp+18h] [bp+8h]@6
  char v21; // [sp+23h] [bp+13h]@5
  KIRQL v22; // [sp+27h] [bp+17h]@1

  v4 = NewIrql;
  *(_DWORD *)NewIrql = 0;
  v5 = a1;
  v6 = (KSPIN_LOCK *)(a1 + 468);
  v18 = 0;
  v7 = KfAcquireSpinLock((PKSPIN_LOCK)(a1 + 468));
  v8 = 8092 - *(_DWORD *)(a1 + 472);
  v22 = v7;
  if ( a3 < (unsigned int)v8 )
  {
    v19 = a3;
LABEL_3:
    v9 = *(_DWORD *)(v5 + 480);
    v10 = v5 - v9 + 8584;
    if ( v19 < (unsigned int)v10 )
      v10 = v19;
    v11 = CopyMemoryAndCheckForChar(v9, a2, v10, *(_BYTE *)(v5 + 75));
    *(_DWORD *)(v5 + 480) += v10;
    *(_DWORD *)v4 += v10;
    *(_DWORD *)(v5 + 472) += v10;
    v21 = v11;
    v12 = v19;
    if ( v10 < (unsigned int)v19 )
    {
      v13 = *(_BYTE *)(v5 + 75);
      v20 = v19 - v10;
      *(_DWORD *)(v5 + 480) = v5 + 492;
      v18 = CopyMemoryAndCheckForChar(v5 + 492, a2 + v10, v12 - v10, v13);
      *(_DWORD *)(v5 + 480) += v20;
      *(_DWORD *)v4 += v20;
      *(_DWORD *)(v5 + 472) += v20;
    }
    if ( *(_DWORD *)(v5 + 300) )
    {
      if ( *(_BYTE *)(v5 + 384) && KeCancelTimer((PKTIMER)(v5 + 312)) )
      {
        --*(_DWORD *)(v5 + 304);
        *(_BYTE *)(v5 + 384) = 0;
      }
      v14 = *(_DWORD *)(v5 + 488);
      if ( v14 && !*(_BYTE *)(v5 + 384) )
      {
        KeSetTimer((PKTIMER)(v5 + 312), (LARGE_INTEGER)(-10000i64 * v14), (PKDPC)(v5 + 352));
        ++*(_DWORD *)(v5 + 304);
        *(_BYTE *)(v5 + 384) = 1;
      }
    }
    v15 = *(_DWORD *)(v5 + 472) > 0x1949u;
    KfReleaseSpinLock((PKSPIN_LOCK)(v5 + 468), v22);
    MoveDataFromBufferToIrp(v5);
    SeeIfIrpShouldBeCompleted(v5);
    if ( v21 || v18 )
      v16 = 2;
    else
      v16 = 0;
    EventNotification(v5, v16 | (v15 != 0 ? 0x400 : 0) | 1);
    return 0;
  }
  v19 = 8092 - *(_DWORD *)(a1 + 472);
  if ( v8 >= (unsigned int)a3 )
    goto LABEL_3;
  if ( *(_BYTE *)(v5 + 465) )
  {
    *(_BYTE *)(v5 + 310) = 1;
    KfReleaseSpinLock(v6, v7);
    *(_DWORD *)v4 = 0;
    return -1073741285;
  }
  KfReleaseSpinLock(v6, v7);
  *(_DWORD *)v4 = a3;
  return 0;
}

//----- (000122BA) --------------------------------------------------------
void __stdcall LockedMemoryCopy(PKSPIN_LOCK SpinLock, void *a2, void *a3, size_t a4)
{
  KIRQL v4; // bl@1

  v4 = KfAcquireSpinLock(SpinLock);
  memcpy(a2, a3, a4);
  KfReleaseSpinLock(SpinLock, v4);
}

//----- (000122F2) --------------------------------------------------------
void __stdcall UartComplete(int a1, PIRP Irp)
{
  IofCompleteRequest(Irp, 0);
  StartNextPacket(a1 + 208);
}

//----- (0001231A) --------------------------------------------------------
int __stdcall IrCommDeviceControl(int a1, PIRP Irp)
{
  int v2; // eax@1
  int v3; // esi@1
  PIRP v4; // edi@1
  struct _IRP::$::$::$::$A02EC6A2CE86544F716F4825015773AC::_IO_STACK_LOCATION *v5; // eax@1
  struct _IRP *v6; // ebx@1
  unsigned int v7; // ecx@1
  signed int v8; // eax@2
  signed int v9; // esi@2
  unsigned int v11; // ecx@5
  bool v12; // cf@23
  int v13; // esi@40
  unsigned int v14; // [sp+10h] [bp-8h]@1
  unsigned int v15; // [sp+14h] [bp-4h]@1
  int v16; // [sp+20h] [bp+8h]@1

  v2 = a1;
  v16 = 0;
  v3 = *(_DWORD *)(v2 + 40);
  v4 = Irp;
  v5 = Irp->Tail.Overlay.CurrentStackLocation;
  v6 = Irp->AssociatedIrp.MasterIrp;
  v14 = *((_DWORD *)v5 + 2);
  v7 = *((_DWORD *)v5 + 1);
  Irp->IoStatus.Information = 0;
  v15 = v7;
  if ( *(_BYTE *)(v3 + 16) )
  {
    v8 = -1073741130;
    v9 = -1073741130;
LABEL_3:
    v4->IoStatus.Status = v8;
    IofCompleteRequest(v4, 0);
    return v9;
  }
  v11 = *((_DWORD *)v5 + 3);
  if ( v11 > 0x1B0050 )
  {
    if ( v11 > 0x1B006C )
    {
      if ( v11 == 1769588 )
      {
        if ( v15 >= 0x3C )
        {
          memset(v6, 0, v15);
          v6->Type = 60;
          v6->MdlAddress = (PMDL)1;
          v6->IoStatus.Status = 1;
          LOWORD(v6->UserIosb) = 12;
          v6->Size = 1;
          v6->ThreadListEntry.Blink = (struct _LIST_ENTRY *)115200;
          v6->IoStatus.Information = 199;
          *(_DWORD *)&v6->RequestorMode = 95;
          *(_DWORD *)&v6->Cancel = 268957696;
          HIWORD(v6->UserIosb) = 1793;
          Irp->IoStatus.Information = 60;
          goto LABEL_81;
        }
        goto LABEL_80;
      }
      if ( v11 != 1769592 )
      {
        if ( v11 == 1769600 )
        {
          if ( v15 >= 4 )
          {
            *(_DWORD *)&v6->Type = 0;
            Irp->IoStatus.Information = 4;
            goto LABEL_81;
          }
        }
        else
        {
          if ( v11 != 1769612 )
          {
            if ( v11 == 1769616 )
            {
              *(_DWORD *)(v3 + 144) = 0;
              *(_DWORD *)(v3 + 484) = 0;
              goto LABEL_81;
            }
            if ( v11 == 2818092 )
              goto LABEL_72;
            goto LABEL_71;
          }
          if ( v15 >= 0x18 )
          {
            memset(v6, 0, v15);
            v6->MdlAddress = *(PMDL *)(v3 + 144);
            *(_DWORD *)&v6->Type = *(_DWORD *)(v3 + 484);
            Irp->IoStatus.Information = 24;
            goto LABEL_81;
          }
        }
        goto LABEL_80;
      }
    }
    else
    {
      if ( v11 == 1769580 )
      {
        if ( v15 >= 0x14 )
        {
          *(_DWORD *)&v6->Type = 0;
          v6->MdlAddress = 0;
          v6->Flags = 0;
          v6->AssociatedIrp.IrpCount = 0;
          v6->ThreadListEntry.Flink = 0;
          LockedMemoryCopy((PKSPIN_LOCK)(v3 + 468), &v6->Flags, (void *)(v3 + 472), 4u);
          Irp->IoStatus.Information = 20;
          v4 = Irp;
          goto LABEL_81;
        }
        goto LABEL_80;
      }
      if ( v11 == 1769556 )
      {
        v12 = v15 < 3;
        goto LABEL_42;
      }
      if ( v11 == 1769560 )
      {
        if ( v15 >= 6 )
        {
          LockedMemoryCopy((PKSPIN_LOCK)(v3 + 40), v6, (void *)(v3 + 72), 6u);
          Irp->IoStatus.Information = 6;
          goto LABEL_81;
        }
        goto LABEL_80;
      }
      if ( v11 == 1769564 )
      {
        if ( v14 >= 6 )
        {
          LockedMemoryCopy((PKSPIN_LOCK)(v3 + 40), (void *)(v3 + 72), v6, 6u);
          goto LABEL_81;
        }
        goto LABEL_80;
      }
      if ( v11 == 1769568 )
      {
        if ( v15 >= 0x10 )
        {
          LockedMemoryCopy((PKSPIN_LOCK)(v3 + 40), v6, (void *)(v3 + 80), 0x10u);
          Irp->IoStatus.Information = 16;
          goto LABEL_81;
        }
LABEL_80:
        v16 = -1073741811;
        goto LABEL_81;
      }
      if ( v11 == 1769572 )
      {
        if ( v14 >= 0x10 )
        {
          LockedMemoryCopy((PKSPIN_LOCK)(v3 + 40), (void *)(v3 + 80), v6, 0x10u);
          goto LABEL_81;
        }
        goto LABEL_80;
      }
      if ( v11 != 1769576 )
      {
LABEL_71:
        DbgPrint("IRCOMM: unhandled ioctl %d \n", (*((_DWORD *)v5 + 3) >> 2) & 0x3F);
LABEL_72:
        v16 = -1073741808;
        goto LABEL_81;
      }
    }
    v12 = v15 < 4;
    goto LABEL_42;
  }
  if ( v11 == 1769552 )
  {
    v12 = v15 < 4;
    goto LABEL_42;
  }
  if ( v11 <= 0x1B0028 )
  {
    if ( v11 == 1769512 )
    {
LABEL_16:
      *(_BYTE *)(v3 + 465) = v11 == 1769508;
LABEL_17:
      v5 = Irp->Tail.Overlay.CurrentStackLocation;
LABEL_43:
      *((_BYTE *)v5 + 3) |= 1u;
      v13 = v3 + 208;
      goto LABEL_44;
    }
    if ( v11 == 1769476 )
    {
      v12 = v14 < 4;
    }
    else
    {
      if ( v11 == 1769480 )
      {
        if ( v14 >= 8 )
        {
          LockedMemoryCopy((PKSPIN_LOCK)(v3 + 40), (void *)(v3 + 64), v6, 8u);
          goto LABEL_81;
        }
        goto LABEL_80;
      }
      if ( v11 != 1769484 )
      {
        if ( v11 == 1769500 )
        {
          if ( v14 >= 0x14 )
          {
            LockedMemoryCopy((PKSPIN_LOCK)(v3 + 40), (void *)(v3 + 44), v6, 0x14u);
            goto LABEL_81;
          }
        }
        else
        {
          if ( v11 != 1769504 )
          {
            if ( v11 == 1769508 )
            {
              v11 = *((_DWORD *)v5 + 3);
              goto LABEL_16;
            }
            goto LABEL_71;
          }
          if ( v15 >= 0x14 )
          {
            LockedMemoryCopy((PKSPIN_LOCK)(v3 + 40), v6, (void *)(v3 + 44), 0x14u);
            Irp->IoStatus.Information = 20;
LABEL_81:
            *(_BYTE *)(v4->Tail.Overlay.PacketType + 3) |= 1u;
            v8 = v16;
            v9 = 259;
            goto LABEL_3;
          }
        }
        goto LABEL_80;
      }
      v12 = v14 < 3;
    }
LABEL_42:
    if ( !v12 )
      goto LABEL_43;
    goto LABEL_80;
  }
  if ( v11 == 1769520 || v11 == 1769524 )
    goto LABEL_17;
  if ( v11 != 1769536 && v11 != 1769540 && v11 != 1769544 )
  {
    if ( v11 == 1769548 )
    {
      if ( v14 >= 4 )
      {
        if ( v6->Type & 1 )
        {
          FlushQueuedPackets(v3 + 100, 4);
          AbortSend(*(_DWORD *)(v3 + 24));
        }
        if ( v6->Type & 2 )
        {
          FlushQueuedPackets(v3 + 256, -1);
          ReadPurge(v3, 1);
        }
        if ( v6->Type & 8 )
          ReadPurge(v3, 0);
        goto LABEL_81;
      }
      goto LABEL_80;
    }
    goto LABEL_71;
  }
  *((_BYTE *)v5 + 3) |= 1u;
  Irp->IoStatus.Information = 0;
  v13 = v3 + 148;
LABEL_44:
  QueuePacket(v13, Irp, 0);
  return 259;
}

//----- (00012708) --------------------------------------------------------
void __stdcall UartStartRoutine(int a1, int a2)
{
  AccessUartState(*(volatile LONG **)(a1 + 24), a2, (int)UartComplete, a1);
}

//----- (0001272A) --------------------------------------------------------
void __stdcall WaitMaskCancelRoutine(int a1, PIRP Irp)
{
  int v2; // esi@1
  KIRQL v3; // al@1

  v2 = *(_DWORD *)(a1 + 40);
  IoReleaseCancelSpinLock(Irp->CancelIrql);
  v3 = KfAcquireSpinLock((PKSPIN_LOCK)(v2 + 204));
  *(_DWORD *)(v2 + 200) = 0;
  KfReleaseSpinLock((PKSPIN_LOCK)(v2 + 204), v3);
  Irp->IoStatus.Status = -1073741536;
  IofCompleteRequest(Irp, 0);
}

//----- (00012782) --------------------------------------------------------
int __stdcall GetCurrentWaitIrp(int a1)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 + 200);
  if ( result )
  {
    if ( _InterlockedExchange((volatile signed __int32 *)(result + 56), 0) )
      *(_DWORD *)(a1 + 200) = 0;
    else
      result = 0;
  }
  return result;
}

//----- (000127B6) --------------------------------------------------------
void __stdcall MaskStartRoutine(int NewIrql, PIRP Irp)
{
  PIRP v2; // esi@1
  struct _IRP::$::$::$::$A02EC6A2CE86544F716F4825015773AC::_IO_STACK_LOCATION *v3; // eax@1
  unsigned int v4; // edx@1
  unsigned int v5; // ebx@1
  int v6; // eax@1
  struct _IRP *v7; // ecx@1
  int v8; // eax@2
  int v9; // edi@5
  int v10; // edx@7
  KIRQL v11; // ST00_1@11
  KIRQL v12; // ST00_1@12
  int v13; // ebx@15
  KIRQL v14; // al@16
  int v15; // ebx@16
  int v16; // eax@17
  KIRQL v17; // [sp+17h] [bp+Bh]@6
  KIRQL v18; // [sp+17h] [bp+Bh]@16

  v2 = Irp;
  v3 = Irp->Tail.Overlay.CurrentStackLocation;
  v4 = *((_DWORD *)v3 + 2);
  v5 = *((_DWORD *)v3 + 1);
  v6 = *((_DWORD *)v3 + 3) - 1769536;
  v7 = Irp->AssociatedIrp.MasterIrp;
  if ( !v6 )
  {
    v9 = NewIrql;
    if ( v5 >= 4 )
    {
      *(_DWORD *)&v7->Type = *(_DWORD *)(NewIrql + 192);
      v2->IoStatus.Status = 0;
      v2->IoStatus.Information = 4;
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  v8 = v6 - 4;
  if ( !v8 )
  {
    v13 = *(_DWORD *)&v7->Type;
    v9 = NewIrql;
    if ( v4 >= 4 )
    {
      v14 = KfAcquireSpinLock((PKSPIN_LOCK)(NewIrql + 204));
      *(_DWORD *)(NewIrql + 196) &= v13;
      *(_DWORD *)(NewIrql + 192) = v13;
      v2->IoStatus.Status = 0;
      v18 = v14;
      v15 = GetCurrentWaitIrp(v9);
      KfReleaseSpinLock((PKSPIN_LOCK)(v9 + 204), v18);
      if ( v15 )
      {
        v16 = *(_DWORD *)(v15 + 12);
        *(_DWORD *)(v15 + 24) = 0;
        *(_DWORD *)(v15 + 28) = 4;
        *(_DWORD *)v16 = 0;
        IofCompleteRequest((PIRP)v15, 0);
      }
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  if ( v8 != 4 )
  {
    IofCompleteRequest(Irp, 0);
    StartNextPacket(NewIrql + 148);
    return;
  }
  v9 = NewIrql;
  if ( v5 < 4 )
  {
LABEL_20:
    Irp->IoStatus.Status = -1073741811;
    goto LABEL_21;
  }
  v17 = KfAcquireSpinLock((PKSPIN_LOCK)(NewIrql + 204));
  if ( *(_DWORD *)(v9 + 200) || (v10 = *(_DWORD *)(v9 + 192)) == 0 )
  {
    v2->IoStatus.Status = -1073741811;
    goto LABEL_14;
  }
  if ( v10 & *(_DWORD *)(v9 + 196) )
  {
    *(_DWORD *)v2->AssociatedIrp.MasterIrp = v10 & *(_DWORD *)(v9 + 196);
    *(_DWORD *)(v9 + 196) = 0;
    v2->IoStatus.Status = 0;
    v2->IoStatus.Information = 4;
LABEL_14:
    KfReleaseSpinLock((PKSPIN_LOCK)(v9 + 204), v17);
LABEL_21:
    IofCompleteRequest(v2, 0);
    goto LABEL_22;
  }
  IoAcquireCancelSpinLock((PKIRQL)&Irp);
  if ( v2->Cancel )
  {
    v11 = (unsigned __int8)Irp;
    v2->IoStatus.Status = -1073741536;
    IoReleaseCancelSpinLock(v11);
    KfReleaseSpinLock((PKSPIN_LOCK)(v9 + 204), v17);
    goto LABEL_14;
  }
  _InterlockedExchange((volatile signed __int32 *)&v2->CancelRoutine, (signed __int32)WaitMaskCancelRoutine);
  v12 = (unsigned __int8)Irp;
  *(_DWORD *)(v9 + 200) = v2;
  IoReleaseCancelSpinLock(v12);
  KfReleaseSpinLock((PKSPIN_LOCK)(v9 + 204), v17);
LABEL_22:
  StartNextPacket(v9 + 148);
}

//----- (00012966) --------------------------------------------------------
void __stdcall EventNotification(int NewIrql, int a2)
{
  int v2; // esi@1
  KSPIN_LOCK *v3; // ebx@1
  int v4; // edi@1
  int v5; // eax@2
  KIRQL v6; // [sp+17h] [bp+Bh]@1

  v2 = NewIrql;
  v3 = (KSPIN_LOCK *)(NewIrql + 204);
  v4 = 0;
  v6 = KfAcquireSpinLock((PKSPIN_LOCK)(NewIrql + 204));
  if ( a2 & *(_DWORD *)(v2 + 192) )
  {
    v4 = GetCurrentWaitIrp(v2);
    v5 = a2 & *(_DWORD *)(v2 + 192);
    if ( v4 )
      **(_DWORD **)(v4 + 12) = v5;
    else
      *(_DWORD *)(v2 + 196) |= v5;
  }
  KfReleaseSpinLock(v3, v6);
  if ( v4 )
  {
    *(_DWORD *)(v4 + 24) = 0;
    *(_DWORD *)(v4 + 28) = 4;
    IofCompleteRequest((PIRP)v4, 0);
  }
}

//----- (00012A12) --------------------------------------------------------
NTSTATUS __stdcall IrdaCreateAddress(const void *a1, HANDLE *a2)
{
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+Ch] [bp-78h]@1
  UNICODE_STRING DestinationString; // [sp+14h] [bp-70h]@1
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+1Ch] [bp-68h]@1
  PHANDLE FileHandle; // [sp+34h] [bp-50h]@1
  int EaBuffer; // [sp+38h] [bp-4Ch]@1
  char v8; // [sp+3Ch] [bp-48h]@1
  char v9; // [sp+3Dh] [bp-47h]@1
  __int16 v10; // [sp+3Eh] [bp-46h]@1
  int v11; // [sp+40h] [bp-44h]@1
  int v12; // [sp+44h] [bp-40h]@1
  int v13; // [sp+48h] [bp-3Ch]@1
  int v14; // [sp+4Ch] [bp-38h]@1
  char v15; // [sp+50h] [bp-34h]@1
  int v16; // [sp+51h] [bp-33h]@1
  __int16 v17; // [sp+55h] [bp-2Fh]@1
  __int16 v18; // [sp+57h] [bp-2Dh]@1
  char v19; // [sp+59h] [bp-2Bh]@1

  v9 = 16;
  EaBuffer = 0;
  v8 = 0;
  v11 = *(_DWORD *)"TransportAddress";
  v12 = *(_DWORD *)"sportAddress";
  v13 = *(_DWORD *)"tAddress";
  v14 = *(_DWORD *)"ress";
  v15 = aTransportaddre[16];
  FileHandle = a2;
  v10 = 42;
  v17 = 30;
  v18 = 26;
  v16 = 1;
  qmemcpy(&v19, a1, 0x1Eu);
  RtlInitUnicodeString(&DestinationString, L"\\Device\\IrDA");
  ObjectAttributes.ObjectName = &DestinationString;
  ObjectAttributes.Length = 24;
  ObjectAttributes.RootDirectory = 0;
  ObjectAttributes.Attributes = 576;
  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  return ZwCreateFile(FileHandle, 0xC0100000, &ObjectAttributes, &IoStatusBlock, 0, 0, 3u, 2u, 0, &EaBuffer, 0x46u);
}

//----- (00012AD4) --------------------------------------------------------
NTSTATUS __stdcall IrdaCreateConnection(HANDLE *a1, int a2)
{
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+Ch] [bp-54h]@1
  UNICODE_STRING DestinationString; // [sp+14h] [bp-4Ch]@1
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+1Ch] [bp-44h]@1
  PHANDLE FileHandle; // [sp+34h] [bp-2Ch]@1
  int EaBuffer; // [sp+38h] [bp-28h]@1
  char v8; // [sp+3Ch] [bp-24h]@1
  char v9; // [sp+3Dh] [bp-23h]@1
  __int16 v10; // [sp+3Eh] [bp-22h]@1
  int v11; // [sp+40h] [bp-20h]@1
  int v12; // [sp+44h] [bp-1Ch]@1
  int v13; // [sp+48h] [bp-18h]@1
  int v14; // [sp+4Ch] [bp-14h]@1
  __int16 v15; // [sp+50h] [bp-10h]@1
  int v16; // [sp+52h] [bp-Eh]@1

  v9 = 17;
  FileHandle = a1;
  v10 = 4;
  EaBuffer = 0;
  v8 = 0;
  v11 = *(_DWORD *)"ConnectionContext";
  v12 = *(_DWORD *)"ectionContext";
  v13 = *(_DWORD *)"onContext";
  v14 = *(_DWORD *)"ntext";
  v15 = *(_WORD *)"t";
  v16 = a2;
  RtlInitUnicodeString(&DestinationString, L"\\Device\\IrDA");
  ObjectAttributes.ObjectName = &DestinationString;
  ObjectAttributes.Length = 24;
  ObjectAttributes.RootDirectory = 0;
  ObjectAttributes.Attributes = 576;
  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  return ZwCreateFile(FileHandle, 0xC0100000, &ObjectAttributes, &IoStatusBlock, 0, 0, 3u, 2u, 0, &EaBuffer, 0x21u);
}

//----- (00012B80) --------------------------------------------------------
NTSTATUS __stdcall IrdaDisconnect(PFILE_OBJECT FileObject)
{
  struct _DEVICE_OBJECT *v1; // eax@1
  PIRP v2; // eax@1
  PIRP v3; // ecx@1
  NTSTATUS result; // eax@2
  int v5; // eax@3
  int v6; // esi@3
  struct _DEVICE_OBJECT *v7; // eax@3
  struct _KEVENT Event; // [sp+8h] [bp-1Ch]@1
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+18h] [bp-Ch]@1
  PIRP Irp; // [sp+20h] [bp-4h]@1

  KeInitializeEvent(&Event, SynchronizationEvent, 0);
  v1 = IoGetRelatedDeviceObject(FileObject);
  v2 = IoBuildDeviceIoControlRequest(3u, v1, 0, 0, 0, 0, 1u, &Event, &IoStatusBlock);
  v3 = v2;
  Irp = v2;
  if ( v2 )
  {
    v5 = v2->Tail.Overlay.PacketType - 36;
    *(_DWORD *)(v5 + 28) = 0;
    *(_DWORD *)(v5 + 32) = 0;
    *(_BYTE *)(v5 + 3) = 0;
    v6 = v3->Tail.Overlay.PacketType - 36;
    *(_BYTE *)v6 = 15;
    *(_BYTE *)(v6 + 1) = 6;
    *(_DWORD *)(v6 + 20) = IoGetRelatedDeviceObject(FileObject);
    *(_DWORD *)(v6 + 24) = FileObject;
    *(_DWORD *)(v6 + 4) = 2;
    *(_DWORD *)(v6 + 8) = 0;
    *(_DWORD *)(v6 + 12) = 0;
    *(_DWORD *)(v6 + 16) = 0;
    v7 = IoGetRelatedDeviceObject(FileObject);
    IofCallDriver(v7, Irp);
    KeWaitForSingleObject(&Event, 0, 0, 0, 0);
    result = IoStatusBlock.Status;
  }
  else
  {
    result = -1073741670;
  }
  return result;
}

//----- (00012C32) --------------------------------------------------------
NTSTATUS __stdcall IrdaAssociateAddress(PFILE_OBJECT FileObject, int a2)
{
  struct _DEVICE_OBJECT *v2; // eax@1
  PIRP v3; // eax@1
  PIRP v4; // ebx@1
  NTSTATUS result; // eax@2
  int v6; // eax@3
  int v7; // esi@3
  struct _DEVICE_OBJECT *v8; // eax@3
  NTSTATUS v9; // esi@3
  struct _KEVENT Event; // [sp+Ch] [bp-18h]@1
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+1Ch] [bp-8h]@1

  KeInitializeEvent(&Event, SynchronizationEvent, 0);
  v2 = IoGetRelatedDeviceObject(FileObject);
  v3 = IoBuildDeviceIoControlRequest(3u, v2, 0, 0, 0, 0, 1u, &Event, &IoStatusBlock);
  v4 = v3;
  if ( v3 )
  {
    v6 = v3->Tail.Overlay.PacketType - 36;
    *(_DWORD *)(v6 + 28) = 0;
    *(_DWORD *)(v6 + 32) = 0;
    *(_BYTE *)(v6 + 3) = 0;
    v7 = v4->Tail.Overlay.PacketType - 36;
    *(_BYTE *)v7 = 15;
    *(_BYTE *)(v7 + 1) = 1;
    *(_DWORD *)(v7 + 20) = IoGetRelatedDeviceObject(FileObject);
    *(_DWORD *)(v7 + 24) = FileObject;
    *(_DWORD *)(v7 + 4) = a2;
    v8 = IoGetRelatedDeviceObject(FileObject);
    v9 = IofCallDriver(v8, v4);
    if ( v9 == 259 )
      KeWaitForSingleObject(&Event, 0, 0, 0, 0);
    if ( v9 >= 0 )
      v9 = IoStatusBlock.Status;
    result = v9;
  }
  else
  {
    result = -1073741670;
  }
  return result;
}

//----- (00012CE8) --------------------------------------------------------
PVOID __stdcall IrdaCreateConnectionForAddress(int a1, int a2, int a3, PVOID Object)
{
  HANDLE *v4; // esi@1
  NTSTATUS v5; // eax@2
  struct _FILE_OBJECT *v6; // ecx@2

  v4 = (HANDLE *)Object;
  *(_DWORD *)Object = 0;
  *(_DWORD *)a3 = 0;
  Object = (PVOID)IrdaCreateConnection(v4, a2);
  if ( (signed int)Object >= 0 )
  {
    v5 = ObReferenceObjectByHandle(*v4, 0, 0, 0, &Object, 0);
    v6 = (struct _FILE_OBJECT *)Object;
    *(_DWORD *)a3 = Object;
    Object = (PVOID)v5;
    if ( v5 < 0 )
    {
      ZwClose(*v4);
      *v4 = 0;
LABEL_6:
      *(_DWORD *)a3 = 0;
      return Object;
    }
    Object = (PVOID)IrdaAssociateAddress(v6, a1);
    if ( (signed int)Object < 0 )
    {
      ZwClose(*v4);
      *v4 = 0;
      ObfDereferenceObject(*(PVOID *)a3);
      goto LABEL_6;
    }
  }
  return Object;
}

//----- (00012D68) --------------------------------------------------------
LONG __stdcall RemoveReferenceOnLink(LONG a1)
{
  LONG result; // eax@1

  result = a1;
  if ( !_InterlockedDecrement((volatile signed __int32 *)(a1 + 4)) )
    result = KeSetEvent((PRKEVENT)(a1 + 8), 0, 0);
  return result;
}

//----- (00012D94) --------------------------------------------------------
PKSPIN_LOCK __stdcall GetCurrentConnection(PKSPIN_LOCK SpinLock)
{
  PKSPIN_LOCK v1; // edi@1
  KIRQL v2; // al@1

  v1 = 0;
  v2 = KfAcquireSpinLock(SpinLock);
  if ( SpinLock[19] == 4 )
  {
    _InterlockedExchangeAdd((volatile signed __int32 *)SpinLock + 18, 1u);
    v1 = SpinLock;
  }
  KfReleaseSpinLock(SpinLock, v2);
  return v1;
}

//----- (00012DD2) --------------------------------------------------------
void *__stdcall ConnectionGetFileObject(int a1)
{
  void *v1; // esi@1

  v1 = *(void **)(*(_DWORD *)(a1 + 28) + 32);
  ObfReferenceObject(v1);
  return v1;
}

//----- (00012DF6) --------------------------------------------------------
LONG_PTR __stdcall ConnectionReleaseFileObject(int a1, PVOID Object)
{
  return ObfDereferenceObject(Object);
}

//----- (00012E0E) --------------------------------------------------------
PSINGLE_LIST_ENTRY __stdcall ConnectionGetBuffer(int a1, int a2)
{
  PSINGLE_LIST_ENTRY result; // eax@4

  if ( a2 )
  {
    if ( a2 == 1 )
    {
      result = GetBuffer(*(PVOID *)(a1 + 84));
    }
    else if ( a2 == 2 )
    {
      result = GetBuffer(*(PVOID *)(a1 + 88));
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = GetBuffer(*(PVOID *)(a1 + 80));
  }
  return result;
}

//----- (00012E4A) --------------------------------------------------------
int __stdcall IrdaRestartDeviceControl(int a1, int a2, int a3)
{
  if ( *(_DWORD *)(a2 + 4) )
  {
    IoFreeMdl(*(PMDL *)(a2 + 4));
    *(_DWORD *)(a2 + 4) = 0;
  }
  return 0;
}

//----- (00012E72) --------------------------------------------------------
NTSTATUS __stdcall IrdaIssueDeviceControl(HANDLE Handle, PVOID Object, void *a3, size_t a4, PVOID VirtualAddress, ULONG Length, char a7)
{
  NTSTATUS result; // eax@2
  HANDLE v8; // ebx@2
  PDEVICE_OBJECT v9; // eax@5
  PIRP v10; // eax@5
  PIRP v11; // esi@5
  MDL *v12; // eax@7
  size_t v13; // ST10_4@12
  int v14; // edi@12
  const void *v15; // ST0C_4@12
  struct _DEVICE_OBJECT *v16; // ebx@12
  int v17; // eax@12
  NTSTATUS v18; // esi@12
  struct _KEVENT Event; // [sp+8h] [bp-18h]@1
  NTSTATUS v20; // [sp+18h] [bp-8h]@6

  KeInitializeEvent(&Event, SynchronizationEvent, 0);
  if ( Handle )
  {
    result = ObReferenceObjectByHandle(Handle, 0, 0, 0, &Handle, 0);
    v8 = Handle;
    if ( result < 0 )
      return result;
  }
  else
  {
    v8 = Object;
    ObfReferenceObject(Object);
  }
  KeResetEvent((PRKEVENT)((char *)v8 + 92));
  v9 = IoGetRelatedDeviceObject((PFILE_OBJECT)v8);
  Object = v9;
  v10 = IoAllocateIrp(v9->StackSize, 1u);
  v11 = v10;
  if ( !v10 )
  {
LABEL_9:
    ObfDereferenceObject(v8);
    return -1073741670;
  }
  v10->UserIosb = (PIO_STATUS_BLOCK)&v20;
  v10->Flags = 4;
  v10->RequestorMode = 0;
  v10->PendingReturned = 0;
  v10->UserEvent = &Event;
  v10->Overlay.AllocationSize.LowPart = 0;
  v10->AssociatedIrp.IrpCount = 0;
  v10->UserBuffer = 0;
  v10->Tail.Overlay.Thread = KeGetCurrentThread();
  v11->Tail.Overlay.OriginalFileObject = (PFILE_OBJECT)v8;
  v11->Tail.Overlay.AuxiliaryBuffer = 0;
  if ( VirtualAddress )
  {
    v12 = IoAllocateMdl(VirtualAddress, Length, 0, 0, v11);
    if ( !v12 )
    {
      IoFreeIrp(v11);
      goto LABEL_9;
    }
    MmBuildMdlForNonPagedPool(v12);
  }
  else
  {
    v11->MdlAddress = 0;
  }
  v13 = a4;
  v14 = v11->Tail.Overlay.PacketType - 36;
  v15 = a3;
  *(_DWORD *)(v14 + 24) = v8;
  v16 = (struct _DEVICE_OBJECT *)Object;
  *(_DWORD *)(v14 + 20) = Object;
  memcpy((void *)(v14 + 4), v15, v13);
  *(_BYTE *)(v14 + 1) = a7;
  *(_BYTE *)v14 = 15;
  v17 = v11->Tail.Overlay.PacketType - 36;
  *(_DWORD *)(v17 + 28) = IrdaRestartDeviceControl;
  *(_DWORD *)(v17 + 32) = 0;
  *(_BYTE *)(v17 + 3) = -32;
  IoEnqueueIrp(v11);
  v18 = IofCallDriver(v16, v11);
  if ( v18 == 259 )
    KeWaitForSingleObject(&Event, UserRequest, 0, 0, 0);
  if ( v18 >= 0 )
    v18 = v20;
  return v18;
}
// 150D4: using guessed type int __stdcall IoEnqueueIrp(_DWORD);

//----- (00012FCC) --------------------------------------------------------
NTSTATUS __stdcall IrdaSetEventHandler(PVOID Object, int a2, int a3, int a4)
{
  int v5; // [sp+0h] [bp-Ch]@1
  int v6; // [sp+4h] [bp-8h]@1
  int v7; // [sp+8h] [bp-4h]@1

  v5 = a2;
  v6 = a3;
  v7 = a4;
  return IrdaIssueDeviceControl(0, Object, &v5, 0xCu, 0, 0, 11);
}

//----- (00013004) --------------------------------------------------------
int __stdcall ClientEventReceive(LONG a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int v8; // edi@2

  if ( *(_BYTE *)(a1 + 24) )
  {
    v8 = 0;
    *(_DWORD *)a6 = a5;
  }
  else
  {
    v8 = (*(int (__thiscall **)(signed __int32, _DWORD, int, int, int, int, int, int))(a1 + 36))(
           _InterlockedExchangeAdd((volatile signed __int32 *)(a1 + 4), 1u),
           *(_DWORD *)(a1 + 32),
           a3,
           a4,
           a5,
           a6,
           a7,
           a8);
    RemoveReferenceOnLink(a1);
  }
  return v8;
}

//----- (00013058) --------------------------------------------------------
NTSTATUS __stdcall GetMaxSendPdu(PFILE_OBJECT FileObject, PVOID OutputBuffer)
{
  PVOID v2; // ebx@1
  struct _DEVICE_OBJECT *v3; // eax@1
  PIRP v4; // eax@1
  struct _DEVICE_OBJECT *v5; // eax@2
  NTSTATUS result; // eax@2
  struct _KEVENT Event; // [sp+Ch] [bp-18h]@1
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+1Ch] [bp-8h]@1
  struct _IRP *OutputBuffera; // [sp+30h] [bp+Ch]@1

  v2 = OutputBuffer;
  *(_DWORD *)OutputBuffer = 50;
  KeInitializeEvent(&Event, 0, 0);
  v3 = IoGetRelatedDeviceObject(FileObject);
  v4 = IoBuildDeviceIoControlRequest(0x120008u, v3, 0, 0, OutputBuffer, 4u, 0, &Event, &IoStatusBlock);
  OutputBuffera = v4;
  if ( v4 )
  {
    *(_DWORD *)(v4->Tail.Overlay.PacketType - 12) = FileObject;
    v5 = IoGetRelatedDeviceObject(FileObject);
    IofCallDriver(v5, OutputBuffera);
    KeWaitForSingleObject(&Event, 0, 0, 0, 0);
    DbgPrint("IRCOMM: maxsendpdu=%d\n", *(_DWORD *)v2);
    result = IoStatusBlock.Status;
  }
  else
  {
    result = -1073741670;
  }
  return result;
}

//----- (000130F0) --------------------------------------------------------
void __stdcall ConnectionPassiveWorkRoutine(PKSPIN_LOCK SpinLock)
{
  LONG v1; // esi@1
  KIRQL v2; // al@1
  KSPIN_LOCK v3; // ecx@2
  bool v4; // zf@3
  KSPIN_LOCK *v5; // ecx@3
  int v6; // ST08_4@13
  ULONG v7; // ST04_4@13
  PDEVICE_OBJECT v8; // eax@13
  PVOID v9; // eax@13
  int v10; // ST08_4@13
  ULONG v11; // ST04_4@13
  PDEVICE_OBJECT v12; // eax@13
  PVOID v13; // eax@13
  int v14; // ST08_4@13
  PDEVICE_OBJECT v15; // eax@13
  signed __int32 v16; // ecx@15
  int OutputBuffer; // [sp+8h] [bp-4h]@1

  v1 = (LONG)SpinLock;
  OutputBuffer = 50;
  v2 = KfAcquireSpinLock(SpinLock);
  if ( SpinLock[19] == 1 )
  {
    KfReleaseSpinLock(SpinLock, v2);
    GetMaxSendPdu(*(PFILE_OBJECT *)(SpinLock[7] + 32), &OutputBuffer);
    v6 = SpinLock[15];
    v7 = OutputBuffer;
    v8 = IoGetRelatedDeviceObject(*(PFILE_OBJECT *)(SpinLock[7] + 32));
    v9 = CreateBufferPool(v8->StackSize, v7, v6);
    v10 = SpinLock[16];
    SpinLock[20] = (KSPIN_LOCK)v9;
    v11 = OutputBuffer;
    v12 = IoGetRelatedDeviceObject(*(PFILE_OBJECT *)(SpinLock[7] + 32));
    v13 = CreateBufferPool(v12->StackSize, v11, v10);
    v14 = SpinLock[17];
    SpinLock[21] = (KSPIN_LOCK)v13;
    v15 = IoGetRelatedDeviceObject(*(PFILE_OBJECT *)(SpinLock[7] + 32));
    SpinLock[22] = (KSPIN_LOCK)CreateBufferPool(v15->StackSize, 1u, v14);
    SpinLock[19] = 4;
    LOBYTE(SpinLock) = 1;
    goto LABEL_14;
  }
  v3 = SpinLock[19] - 3;
  LOBYTE(SpinLock) = 0;
  if ( !v3 )
  {
    *(_DWORD *)(v1 + 76) = 0;
    v5 = (KSPIN_LOCK *)v1;
    goto LABEL_12;
  }
  v4 = v3 == 2;
  v5 = (KSPIN_LOCK *)v1;
  if ( !v4 )
  {
LABEL_12:
    KfReleaseSpinLock(v5, v2);
    goto LABEL_14;
  }
  KfReleaseSpinLock((PKSPIN_LOCK)v1, v2);
  IrdaDisconnect(*(PFILE_OBJECT *)(*(_DWORD *)(v1 + 28) + 32));
  if ( *(_DWORD *)(v1 + 80) )
  {
    FreeBufferPool(*(PVOID *)(v1 + 80));
    *(_DWORD *)(v1 + 80) = 0;
  }
  if ( *(_DWORD *)(v1 + 84) )
  {
    FreeBufferPool(*(PVOID *)(v1 + 84));
    *(_DWORD *)(v1 + 84) = 0;
  }
  if ( *(_DWORD *)(v1 + 88) )
  {
    FreeBufferPool(*(PVOID *)(v1 + 88));
    *(_DWORD *)(v1 + 88) = 0;
  }
  *(_DWORD *)(v1 + 76) = 0;
LABEL_14:
  if ( !*(_BYTE *)(v1 + 24) )
  {
    v16 = _InterlockedExchangeAdd((volatile signed __int32 *)(v1 + 4), 1u);
    (*(void (__thiscall **)(signed __int32, _DWORD, PKSPIN_LOCK, int))(v1 + 40))(
      v16,
      *(_DWORD *)(v1 + 32),
      SpinLock,
      OutputBuffer);
    RemoveReferenceOnLink(v1);
  }
  if ( !(_BYTE)SpinLock )
    RemoveReferenceOnLink(v1);
}

//----- (0001322A) --------------------------------------------------------
void __stdcall RemoveReferenceFromConnection(PKSPIN_LOCK SpinLock)
{
  KIRQL v1; // bl@1

  v1 = KfAcquireSpinLock(SpinLock);
  if ( !_InterlockedDecrement((volatile signed __int32 *)SpinLock + 18) )
    ExQueueWorkItem((PWORK_QUEUE_ITEM)(SpinLock + 11), 0);
  KfReleaseSpinLock(SpinLock, v1);
}

//----- (0001326C) --------------------------------------------------------
LONG __stdcall RemoveRefTdiObjects(LONG a1)
{
  LONG result; // eax@1

  result = a1;
  if ( !_InterlockedDecrement((volatile signed __int32 *)a1) )
    result = KeSetEvent((PRKEVENT)(a1 + 4), 0, 0);
  return result;
}

//----- (00013298) --------------------------------------------------------
void __stdcall CloseTdiObjects(PVOID P)
{
  void *v1; // ecx@3
  void *v2; // ecx@7

  RemoveRefTdiObjects((LONG)P);
  KeWaitForSingleObject((char *)P + 4, 0, 0, 0, 0);
  if ( *((_DWORD *)P + 5) )
  {
    ZwClose(*((HANDLE *)P + 5));
    *((_DWORD *)P + 5) = 0;
  }
  v1 = (void *)*((_DWORD *)P + 6);
  if ( v1 )
  {
    ObfDereferenceObject(v1);
    *((_DWORD *)P + 6) = 0;
  }
  if ( *((_DWORD *)P + 7) )
  {
    ZwClose(*((HANDLE *)P + 7));
    *((_DWORD *)P + 7) = 0;
  }
  v2 = (void *)*((_DWORD *)P + 8);
  if ( v2 )
  {
    ObfDereferenceObject(v2);
    *((_DWORD *)P + 8) = 0;
  }
  memset(P, 0, 0x24u);
  ExFreePoolWithTag(P, 0);
}

//----- (00013316) --------------------------------------------------------
HRESULT __stdcall StringCbCopyA(STRSAFE_LPSTR pszDest, size_t cbDest, STRSAFE_LPCSTR pszSrc)
{
  HRESULT result; // eax@1
  STRSAFE_LPSTR v4; // eax@5
  HRESULT v5; // ebx@5
  size_t v6; // esi@5
  char v7; // cl@7

  result = 0;
  if ( !cbDest || cbDest > 0x7FFFFFFF )
    result = -2147024809;
  if ( result >= 0 )
  {
    v4 = pszDest;
    v5 = 0;
    v6 = cbDest;
    if ( !cbDest )
      goto LABEL_14;
    do
    {
      if ( !(2147483646 - cbDest + v6) )
        break;
      v7 = v4[pszSrc - pszDest];
      if ( !v7 )
        break;
      *v4++ = v7;
      --v6;
    }
    while ( v6 );
    if ( !v6 )
    {
LABEL_14:
      --v4;
      v5 = -2147024774;
    }
    *v4 = 0;
    result = v5;
  }
  return result;
}

//----- (0001337E) --------------------------------------------------------
NTSTATUS __stdcall InitiateConnection(struct _FILE_OBJECT *a1, int a2, STRSAFE_LPCSTR pszSrc)
{
  NTSTATUS result; // eax@2
  struct _DEVICE_OBJECT *v4; // eax@3
  PIRP v5; // eax@3
  PIRP v6; // ecx@3
  struct _FILE_OBJECT *v7; // ST20_4@5
  int v8; // eax@5
  int v9; // esi@5
  struct _FILE_OBJECT *v10; // eax@5
  struct _DEVICE_OBJECT *v11; // eax@5
  struct _KEVENT Event; // [sp+8h] [bp-68h]@3
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+18h] [bp-58h]@3
  int v14; // [sp+20h] [bp-50h]@5
  int v15; // [sp+24h] [bp-4Ch]@5
  int v16; // [sp+28h] [bp-48h]@5
  int v17; // [sp+2Ch] [bp-44h]@5
  int v18; // [sp+30h] [bp-40h]@5
  int *v19; // [sp+34h] [bp-3Ch]@5
  PIRP Irp; // [sp+38h] [bp-38h]@3
  PFILE_OBJECT FileObject; // [sp+3Ch] [bp-34h]@1
  int v22; // [sp+40h] [bp-30h]@5
  int v23; // [sp+48h] [bp-28h]@1
  char pszDest; // [sp+4Ch] [bp-24h]@3
  __int16 v25; // [sp+64h] [bp-Ch]@1

  FileObject = a1;
  memset(&v23, 0, 0x1Cu);
  v25 = 0;
  if ( strlen(pszSrc) + 1 <= 0x1A )
  {
    StringCbCopyA(&pszDest, 0x1Au, pszSrc);
    KeInitializeEvent(&Event, 0, 0);
    v4 = IoGetRelatedDeviceObject(FileObject);
    v5 = IoBuildDeviceIoControlRequest(3u, v4, 0, 0, 0, 0, 1u, &Event, &IoStatusBlock);
    v6 = v5;
    Irp = v5;
    if ( v5 )
    {
      v7 = FileObject;
      v23 = a2;
      v22 = 1;
      v14 = 0;
      v15 = 0;
      v16 = 0;
      v17 = 0;
      v18 = 42;
      v19 = &v22;
      v8 = v5->Tail.Overlay.PacketType - 36;
      *(_DWORD *)(v8 + 28) = 0;
      *(_DWORD *)(v8 + 32) = 0;
      *(_BYTE *)(v8 + 3) = 0;
      v9 = v6->Tail.Overlay.PacketType - 36;
      *(_BYTE *)v9 = 15;
      *(_BYTE *)(v9 + 1) = 3;
      *(_DWORD *)(v9 + 20) = IoGetRelatedDeviceObject(v7);
      v10 = FileObject;
      *(_DWORD *)(v9 + 24) = FileObject;
      *(_DWORD *)(v9 + 8) = &v14;
      *(_DWORD *)(v9 + 12) = 0;
      *(_DWORD *)(v9 + 16) = 0;
      v11 = IoGetRelatedDeviceObject(v10);
      IofCallDriver(v11, Irp);
      KeWaitForSingleObject(&Event, 0, 0, 0, 0);
      result = IoStatusBlock.Status;
    }
    else
    {
      result = -1073741670;
    }
  }
  else
  {
    result = -1073741811;
  }
  return result;
}

//----- (000134A2) --------------------------------------------------------
void __stdcall CloseTdiLink(PKSPIN_LOCK SpinLock)
{
  KSPIN_LOCK v1; // eax@1
  KIRQL v2; // al@1
  LONG v3; // ST10_4@5
  char v4; // [sp+Bh] [bp-1h]@1

  v1 = SpinLock[7];
  *((_BYTE *)SpinLock + 24) = 1;
  v4 = 0;
  IrdaSetEventHandler(*(PVOID *)(v1 + 24), 3, 0, 0);
  IrdaSetEventHandler(*(PVOID *)(SpinLock[7] + 24), 1, 0, 0);
  IrdaSetEventHandler(*(PVOID *)(SpinLock[7] + 24), 0, 0, 0);
  v2 = KfAcquireSpinLock(SpinLock);
  if ( SpinLock[19] == 4 )
  {
    SpinLock[19] = 5;
    v4 = 1;
  }
  KfReleaseSpinLock(SpinLock, v2);
  if ( v4 )
    RemoveReferenceFromConnection(SpinLock);
  RemoveReferenceOnLink((LONG)SpinLock);
  KeWaitForSingleObject(SpinLock + 2, 0, 0, 0, 0);
  v3 = SpinLock[7];
  SpinLock[19] = 6;
  RemoveRefTdiObjects(v3);
  SpinLock[7] = 0;
  ExFreePoolWithTag(SpinLock, 0);
}

//----- (0001354A) --------------------------------------------------------
void __stdcall ReleaseConnection(PKSPIN_LOCK SpinLock)
{
  RemoveReferenceFromConnection(SpinLock);
}

//----- (0001355A) --------------------------------------------------------
int __stdcall LinkEventDisconnect(PKSPIN_LOCK SpinLock, int a2, int a3, int a4, int a5, int a6, int a7)
{
  char v7; // bl@1
  KIRQL v8; // al@2

  v7 = 0;
  if ( !*((_BYTE *)SpinLock + 24) )
  {
    v8 = KfAcquireSpinLock(SpinLock);
    if ( SpinLock[19] == 4 )
    {
      SpinLock[19] = 5;
      v7 = 1;
    }
    KfReleaseSpinLock(SpinLock, v8);
    if ( v7 )
      RemoveReferenceFromConnection(SpinLock);
  }
  return 0;
}

//----- (000135A4) --------------------------------------------------------
int __stdcall IrdaCompleteAcceptIrp(int a1, PIRP Irp, PKSPIN_LOCK SpinLock)
{
  PKSPIN_LOCK v3; // esi@1
  KIRQL SpinLock_3; // [sp+1Bh] [bp+13h]@1

  v3 = SpinLock;
  SpinLock_3 = KfAcquireSpinLock(SpinLock);
  if ( Irp->IoStatus.Status < 0 )
  {
    v3[19] = 3;
  }
  else
  {
    v3[19] = 1;
    ExQueueWorkItem((PWORK_QUEUE_ITEM)(v3 + 11), 0);
  }
  KfReleaseSpinLock(v3, SpinLock_3);
  if ( Irp->IoStatus.Status < 0 )
    RemoveReferenceFromConnection(v3);
  IoFreeIrp(Irp);
  return -1073741802;
}

//----- (0001360C) --------------------------------------------------------
PVOID __stdcall OpenTdiObjects(STRSAFE_LPCSTR pszSrc, char a2)
{
  PVOID result; // eax@3
  PVOID v3; // esi@4
  HANDLE *v4; // edi@8
  NTSTATUS v5; // eax@9
  PVOID Object; // [sp+4h] [bp-34h]@9
  char v7; // [sp+10h] [bp-28h]@8
  char pszDest; // [sp+14h] [bp-24h]@6

  if ( a2 || strlen(pszSrc) + 1 <= 0x1A )
  {
    v3 = ExAllocatePoolWithTag(0, 0x24u, DebugMemoryTag);
    result = 0;
    if ( v3 )
    {
      memset(v3, 0, 0x24u);
      *(_DWORD *)v3 = 1;
      KeInitializeEvent((PRKEVENT)((char *)v3 + 4), 0, 0);
      if ( a2 )
        pszDest = 0;
      else
        StringCbCopyA(&pszDest, 0x1Au, pszSrc);
      v4 = (HANDLE *)((char *)v3 + 20);
      if ( IrdaCreateAddress(&v7, (HANDLE *)v3 + 5) < 0
        || (v5 = ObReferenceObjectByHandle(*v4, 0, 0, 0, &Object, 0), *((_DWORD *)v3 + 6) = Object, v5)
        || (signed int)IrdaCreateConnectionForAddress((int)*v4, 0, (int)((char *)v3 + 32), (char *)v3 + 28) < 0 )
      {
        CloseTdiObjects(v3);
        result = 0;
      }
      else
      {
        result = v3;
      }
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (000136EE) --------------------------------------------------------
int __stdcall LinkEventConnect(PKSPIN_LOCK SpinLock, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  PKSPIN_LOCK v9; // edi@1
  PIRP v10; // esi@1
  int result; // eax@2
  KIRQL v12; // dl@3
  struct _IRP::$::$::$::$A02EC6A2CE86544F716F4825015773AC::_IO_STACK_LOCATION *v13; // eax@5
  int v14; // eax@6
  int v15; // eax@7
  int v16; // eax@8
  PDEVICE_OBJECT SpinLocka; // [sp+14h] [bp+8h]@1

  v9 = SpinLock;
  SpinLocka = IoGetRelatedDeviceObject(*(PFILE_OBJECT *)(SpinLock[7] + 32));
  v10 = IoAllocateIrp(SpinLocka->StackSize, 0);
  if ( v10 )
  {
    v12 = KfAcquireSpinLock(v9);
    if ( v9[19] || *((_BYTE *)v9 + 24) )
    {
      KfReleaseSpinLock(v9, v12);
      IoFreeIrp(v10);
      result = -1073741258;
    }
    else
    {
      v9[19] = 2;
      _InterlockedExchangeAdd((volatile signed __int32 *)v9 + 18, 1u);
      _InterlockedExchangeAdd((volatile signed __int32 *)v9 + 1, 1u);
      KfReleaseSpinLock(v9, v12);
      v13 = v10->Tail.Overlay.CurrentStackLocation;
      if ( IrdaCompleteAcceptIrp )
      {
        v14 = (int)((char *)v13 - 36);
        *(_DWORD *)(v14 + 28) = IrdaCompleteAcceptIrp;
        *(_DWORD *)(v14 + 32) = v9;
        *(_BYTE *)(v14 + 3) = -32;
      }
      else
      {
        v15 = (int)((char *)v13 - 36);
        *(_DWORD *)(v15 + 28) = 0;
        *(_DWORD *)(v15 + 32) = 0;
        *(_BYTE *)(v15 + 3) = 0;
      }
      v16 = v10->Tail.Overlay.PacketType - 36;
      *(_BYTE *)v16 = 15;
      *(_BYTE *)(v16 + 1) = 5;
      *(_DWORD *)(v16 + 20) = SpinLocka;
      *(_DWORD *)(v16 + 24) = *(_DWORD *)(v9[7] + 32);
      *(_DWORD *)(v16 + 4) = 0;
      *(_DWORD *)(v16 + 8) = 0;
      --v10->CurrentLocation;
      v10->Tail.Overlay.PacketType -= 36;
      *(_DWORD *)a9 = v10;
      *(_DWORD *)a8 = v9;
      result = -1073741802;
    }
  }
  else
  {
    result = -1073741670;
  }
  return result;
}

//----- (000137E8) --------------------------------------------------------
signed int __stdcall CreateTdiLink(int a1, int a2, const char *a3, char a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11)
{
  PVOID v11; // eax@1
  int v12; // esi@1
  NTSTATUS v14; // edi@3
  int v15; // eax@6
  KIRQL v16; // al@10
  PWORK_QUEUE_ITEM WorkItem; // [sp+18h] [bp-Ch]@3
  char v18; // [sp+1Ch] [bp-8h]@6
  char v19; // [sp+1Dh] [bp-7h]@6

  *(_DWORD *)a5 = 0;
  v11 = ExAllocatePoolWithTag(0, 0x5Cu, DebugMemoryTag);
  v12 = (int)v11;
  if ( !v11 )
    return -1073741670;
  memset(v11, 0, 0x5Cu);
  WorkItem = (PWORK_QUEUE_ITEM)(v12 + 44);
  *(_DWORD *)(v12 + 44) = 0;
  *(_DWORD *)v12 = 0;
  *(_DWORD *)(v12 + 52) = ConnectionPassiveWorkRoutine;
  *(_DWORD *)(v12 + 56) = v12;
  *(_DWORD *)(v12 + 4) = 1;
  KeInitializeEvent((PRKEVENT)(v12 + 8), 0, 0);
  *(_DWORD *)(v12 + 36) = a7;
  *(_DWORD *)(v12 + 40) = a8;
  *(_DWORD *)(v12 + 32) = a6;
  *(_DWORD *)(v12 + 60) = a9;
  *(_DWORD *)(v12 + 64) = a10;
  *(_DWORD *)(v12 + 68) = a11;
  *(_DWORD *)(v12 + 76) = 0;
  _InterlockedExchangeAdd((volatile signed __int32 *)a1, 1u);
  *(_DWORD *)(v12 + 28) = a1;
  v14 = IrdaSetEventHandler(*(PVOID *)(a1 + 24), 3, (int)ClientEventReceive, v12);
  if ( v14 < 0 )
    goto LABEL_12;
  v14 = IrdaSetEventHandler(*(PVOID *)(*(_DWORD *)(v12 + 28) + 24), 1, (int)LinkEventDisconnect, v12);
  if ( v14 < 0 )
    goto LABEL_12;
  *(_DWORD *)a5 = v12;
  if ( a4 )
  {
    v14 = InitiateConnection(*(struct _FILE_OBJECT **)(*(_DWORD *)(v12 + 28) + 32), a2, a3);
    if ( v14 >= 0 )
    {
      v16 = KfAcquireSpinLock((PKSPIN_LOCK)v12);
      _InterlockedExchangeAdd((volatile signed __int32 *)(v12 + 72), 1u);
      _InterlockedExchangeAdd((volatile signed __int32 *)(v12 + 4), 1u);
      *(_DWORD *)(v12 + 76) = 1;
      KfReleaseSpinLock((PKSPIN_LOCK)v12, v16);
      ExQueueWorkItem(WorkItem, 0);
      return v14;
    }
    *(_DWORD *)a5 = 0;
LABEL_12:
    if ( *(_DWORD *)(v12 + 28) )
    {
      RemoveRefTdiObjects(*(_DWORD *)(v12 + 28));
      *(_DWORD *)(v12 + 28) = 0;
    }
    ExFreePoolWithTag((PVOID)v12, 0);
    return v14;
  }
  v15 = *(_DWORD *)(v12 + 28);
  LOBYTE(WorkItem) = 0;
  *(_WORD *)((char *)&WorkItem + 1) = 1025;
  BYTE3(WorkItem) = 1;
  v18 = 1;
  v19 = 1;
  v14 = IrdaIASOctetSet(*(PFILE_OBJECT *)(v15 + 24), (int)"IrDA:IrCOMM", (int)"Parameters", (int)&WorkItem, 6u);
  if ( v14 < 0 )
    goto LABEL_12;
  v14 = IrdaSetEventHandler(*(PVOID *)(*(_DWORD *)(v12 + 28) + 24), 0, (int)LinkEventConnect, v12);
  if ( v14 < 0 )
    goto LABEL_12;
  return 0;
}

//----- (000139B0) --------------------------------------------------------
void __stdcall RemoveReferenceOnBufferPool(PVOID P)
{
  PSINGLE_LIST_ENTRY i; // eax@2
  PSINGLE_LIST_ENTRY v2; // esi@4

  if ( !_InterlockedDecrement((volatile signed __int32 *)P + 4) )
  {
    for ( i = InterlockedPopEntrySList((PSLIST_HEADER)P + 1); ; i = InterlockedPopEntrySList((PSLIST_HEADER)P + 1) )
    {
      v2 = i;
      if ( !i )
        break;
      IoFreeIrp((PIRP)i[6].Next);
      IoFreeMdl((PMDL)v2[5].Next);
      ExFreePoolWithTag(v2, 0);
    }
    ExFreePoolWithTag(P, 0);
  }
}

//----- (00013A14) --------------------------------------------------------
void __stdcall FreeBufferPool(PVOID P)
{
  RemoveReferenceOnBufferPool(P);
}

//----- (00013A24) --------------------------------------------------------
PSINGLE_LIST_ENTRY __stdcall GetBuffer(PVOID P)
{
  PSINGLE_LIST_ENTRY result; // eax@2

  if ( P )
  {
    _InterlockedExchangeAdd((volatile signed __int32 *)P + 4, 1u);
    result = InterlockedPopEntrySList((PSLIST_HEADER)P + 1);
    if ( result )
      return result;
    RemoveReferenceOnBufferPool(P);
  }
  return 0;
}

//----- (00013A5A) --------------------------------------------------------
void __stdcall FreeBuffer(PSINGLE_LIST_ENTRY ListEntry)
{
  struct _SINGLE_LIST_ENTRY *v1; // esi@1

  v1 = ListEntry[1].Next;
  InterlockedPushEntrySList((PSLIST_HEADER)&v1[2], ListEntry);
  RemoveReferenceOnBufferPool(v1);
}

//----- (00013A80) --------------------------------------------------------
PVOID __stdcall CreateBufferPool(CCHAR StackSize, ULONG Length, int a3)
{
  PVOID v3; // ebx@1
  PVOID result; // eax@1
  PVOID v5; // eax@4
  PVOID v6; // esi@4
  PIRP v7; // eax@5
  MDL *v8; // eax@6
  unsigned int v9; // [sp+8h] [bp-4h]@2

  v3 = ExAllocatePoolWithTag(0, 0x18u, DebugMemoryTag);
  result = 0;
  if ( v3 )
  {
    *((_DWORD *)v3 + 4) = 1;
    *(_DWORD *)v3 = 0;
    *((_DWORD *)v3 + 2) = 0;
    *((_DWORD *)v3 + 3) = 0;
    v9 = 0;
    if ( (unsigned int)a3 <= 0 )
    {
LABEL_8:
      result = v3;
    }
    else
    {
      while ( Length < 0xFFFFFFDF )
      {
        v5 = ExAllocatePoolWithTag(0, Length + 32, DebugMemoryTag);
        v6 = v5;
        if ( !v5 )
          break;
        *((_DWORD *)v5 + 7) = Length;
        *((_DWORD *)v5 + 2) = FreeBuffer;
        *((_DWORD *)v5 + 1) = v3;
        v7 = IoAllocateIrp(StackSize, 0);
        *((_DWORD *)v6 + 6) = v7;
        if ( !v7 )
          goto LABEL_11;
        v8 = IoAllocateMdl((char *)v6 + 32, Length, 0, 0, 0);
        *((_DWORD *)v6 + 5) = v8;
        if ( !v8 )
        {
          IoFreeIrp(*((PIRP *)v6 + 6));
LABEL_11:
          ExFreePoolWithTag(v6, 0);
          break;
        }
        MmBuildMdlForNonPagedPool(v8);
        InterlockedPushEntrySList((PSLIST_HEADER)v3 + 1, (PSINGLE_LIST_ENTRY)v6);
        ++v9;
        if ( v9 >= a3 )
          goto LABEL_8;
      }
      RemoveReferenceOnBufferPool(v3);
      result = 0;
    }
  }
  return result;
}

//----- (00013B60) --------------------------------------------------------
NTSTATUS __stdcall IrdaIASOctetSet(PFILE_OBJECT FileObject, int pszSrc, int a3, int a4, size_t a5)
{
  NTSTATUS result; // eax@2
  struct _DEVICE_OBJECT *v6; // eax@6
  PIRP v7; // edi@6
  struct _FILE_OBJECT *v8; // ST20_4@8
  struct _DEVICE_OBJECT *v9; // eax@8
  struct _KEVENT Event; // [sp+Ch] [bp-56Ch]@4
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+1Ch] [bp-55Ch]@6
  void *v12; // [sp+24h] [bp-554h]@1
  PFILE_OBJECT v13; // [sp+28h] [bp-550h]@1
  char InputBuffer; // [sp+2Ch] [bp-54Ch]@3
  char pszDest; // [sp+6Ch] [bp-50Ch]@4
  int v16; // [sp+16Ch] [bp-40Ch]@4
  __int16 v17; // [sp+170h] [bp-408h]@4
  char v18; // [sp+172h] [bp-406h]@6

  v12 = (void *)a4;
  v13 = FileObject;
  if ( strlen((const char *)pszSrc) + 1 > 0x40
    || (StringCbCopyA(&InputBuffer, 0x40u, (STRSAFE_LPCSTR)pszSrc), strlen((const char *)a3) + 1 > 0x100) )
  {
    result = -1073741811;
  }
  else
  {
    StringCbCopyA(&pszDest, 0x100u, (STRSAFE_LPCSTR)a3);
    KeInitializeEvent(&Event, 0, 0);
    v16 = 2;
    v17 = a5;
    if ( a5 <= 0x400 )
    {
      memcpy(&v18, v12, a5);
      v6 = IoGetRelatedDeviceObject(FileObject);
      v7 = IoBuildDeviceIoControlRequest(0x120010u, v6, &InputBuffer, 0x548u, 0, 0, 0, &Event, &IoStatusBlock);
      if ( v7 )
      {
        v8 = v13;
        *(_DWORD *)(v7->Tail.Overlay.PacketType - 12) = v13;
        v9 = IoGetRelatedDeviceObject(v8);
        IofCallDriver(v9, v7);
        KeWaitForSingleObject(&Event, 0, 0, 0, 0);
        result = IoStatusBlock.Status;
      }
      else
      {
        result = -1073741670;
      }
    }
    else
    {
      result = -1073741789;
    }
  }
  return result;
}

//----- (00013CB6) --------------------------------------------------------
LONG __stdcall RemoveRefereneToConnection(volatile LONG *Addend)
{
  LONG result; // eax@1

  result = InterlockedDecrement(Addend);
  if ( !result )
    result = KeSetEvent((PRKEVENT)(Addend + 1), 0, 0);
  return result;
}

//----- (00013CE2) --------------------------------------------------------
int __stdcall HandleControlInformation(int a1, unsigned int a2, int a3)
{
  unsigned int v3; // esi@1
  int result; // eax@1
  char v5; // cl@2
  signed int v6; // edx@2
  bool v7; // zf@5
  char v8; // cl@5
  unsigned __int8 v9; // [sp+13h] [bp+Fh]@2
  int v10; // [sp+14h] [bp+10h]@1

  v3 = a2;
  result = a2 + a3;
  v10 = result;
  if ( a2 < result )
  {
    do
    {
      v5 = *(_BYTE *)v3;
      v6 = 0;
      v9 = *(_BYTE *)(v3 + 1);
      if ( *(_DWORD *)(a1 + 32) && (v5 == 32 || v5 == 33) )
      {
        v7 = v5 == 32;
        v8 = *(_BYTE *)(v3 + 2);
        if ( v7 )
          v8 = (*(_BYTE *)(v3 + 2) >> 1) & 1 | 2 * (*(_BYTE *)(v3 + 2) & 9 | 4 * (v8 & 4));
        *(_DWORD *)(a1 + 112) = v8 & 0xF0;
        if ( v8 & 1 )
          v6 = 8;
        if ( v8 & 2 )
          v6 |= 0x10u;
        if ( v8 & 4 )
          v6 |= 0x100u;
        if ( v8 & 8 )
          v6 |= 0x20u;
        (*(void (__stdcall **)(_DWORD, signed int))(a1 + 32))(*(_DWORD *)(a1 + 36), v6);
      }
      result = v9;
      v3 += v9 + 2;
    }
    while ( v3 < v10 );
  }
  return result;
}

//----- (00013D86) --------------------------------------------------------
signed int __stdcall LinkReceiveHandler(int a1, int a2, unsigned int a3, int a4, int a5, int *a6, int a7)
{
  signed int result; // eax@2
  unsigned __int8 v8; // dl@3
  int v9; // eax@3
  int (__stdcall *v10)(_DWORD, _DWORD, _DWORD, _DWORD); // edx@6
  int v11; // ecx@8

  *(_DWORD *)a7 = 0;
  *(_DWORD *)a5 = a4;
  if ( a3 < 1 )
    return 0;
  v8 = *(_BYTE *)a6;
  v9 = *(_BYTE *)a6;
  if ( v9 + 1 <= a3 && (!v8 || v8 >= 3u) )
  {
    v10 = *(int (__stdcall **)(_DWORD, _DWORD, _DWORD, _DWORD))(a1 + 24);
    if ( v10 )
    {
      if ( a3 - v9 != 1 )
      {
        v11 = v10(*(_DWORD *)(a1 + 28), (char *)a6 + v9 + 1, a3 - v9 - 1, &a7);
        result = -1073741285;
        if ( v11 == -1073741285 )
        {
          *(_DWORD *)a5 = 0;
          return result;
        }
      }
    }
    HandleControlInformation(a1, (unsigned int)((char *)a6 + 1), *(_BYTE *)a6);
  }
  return 0;
}

//----- (00013E0C) --------------------------------------------------------
void __stdcall LinkStateHandler(int a1, int a2, int a3)
{
  char v3; // al@1
  void (__stdcall *v4)(_DWORD, _DWORD); // eax@2
  int v5; // ST0C_4@3
  KSPIN_LOCK *v6; // ST0C_4@4
  KSPIN_LOCK *v7; // edi@4
  unsigned int v8; // eax@5

  v3 = a2;
  *(_BYTE *)(a1 + 44) = a2;
  if ( v3 )
  {
    v6 = *(KSPIN_LOCK **)(a1 + 20);
    *(_DWORD *)(a1 + 40) = a3;
    v7 = GetCurrentConnection(v6);
    if ( v7 )
    {
      LOBYTE(a2) = 4;
      SendSynchronousControlInfo((int)v7, 0, 1, &a2);
      SendSynchronousControlInfo((int)v7, 34, 0, 0);
      v8 = *(_DWORD *)(a1 + 104);
      LOBYTE(a2) = *(_DWORD *)(a1 + 104) >> 24;
      BYTE2(a2) = BYTE1(v8);
      BYTE3(a2) = *(_BYTE *)(a1 + 104);
      BYTE1(a2) = v8 >> 16;
      SendSynchronousControlInfo((int)v7, 16, 4, &a2);
      LOBYTE(a2) = (*(_DWORD *)(a1 + 96) == 0 ? 0 : 4) | (*(_DWORD *)(a1 + 100) == 0 ? 0 : 8);
      SendSynchronousControlInfo((int)v7, 32, 1, &a2);
      ReleaseConnection(v7);
    }
    ProcessSendAtPassive(a1);
  }
  else
  {
    v4 = *(void (__stdcall **)(_DWORD, _DWORD))(a1 + 32);
    if ( v4 )
    {
      v5 = *(_DWORD *)(a1 + 36);
      *(_DWORD *)(a1 + 112) = 0;
      v4(v5, 312);
    }
  }
}

//----- (00013EDC) --------------------------------------------------------
void __stdcall FreeConnection(PVOID P)
{
  RemoveRefereneToConnection((volatile LONG *)P);
  KeWaitForSingleObject((char *)P + 4, 0, 0, 0, 0);
  if ( *((_DWORD *)P + 5) )
    CloseTdiLink(*((PKSPIN_LOCK *)P + 5));
  ExFreePoolWithTag(P, 0);
}

//----- (00013F1C) --------------------------------------------------------
signed int __stdcall ReceiveCompletion(int a1, int a2, int a3)
{
  (*(void (__stdcall **)(int))(a3 + 8))(a3);
  return -1073741802;
}

//----- (00013F36) --------------------------------------------------------
int __stdcall IndicateReceiveBufferSpaceAvailible(int a1)
{
  int v1; // eax@1
  int v2; // esi@1
  struct _FILE_OBJECT *v3; // edi@2
  PSINGLE_LIST_ENTRY v4; // esi@2
  struct _SINGLE_LIST_ENTRY *v5; // eax@3
  int v6; // eax@4
  int v7; // eax@5
  int v8; // eax@6
  struct _DEVICE_OBJECT *DeviceObject; // [sp+8h] [bp-8h]@3
  int v11; // [sp+Ch] [bp-4h]@1

  v1 = (int)GetCurrentConnection(*(PKSPIN_LOCK *)(a1 + 20));
  v2 = v1;
  v11 = v1;
  if ( v1 )
  {
    v3 = (struct _FILE_OBJECT *)ConnectionGetFileObject(v1);
    v4 = ConnectionGetBuffer(v2, 2);
    if ( v4 )
    {
      DeviceObject = IoGetRelatedDeviceObject(v3);
      IoReuseIrp((PIRP)v4[6].Next, 0);
      v4[6].Next[25].Next = (struct _SINGLE_LIST_ENTRY *)v3;
      v4[3].Next = (struct _SINGLE_LIST_ENTRY *)a1;
      v5 = v4[6].Next[24].Next;
      if ( ReceiveCompletion )
      {
        v6 = (int)&v5[-9];
        *(_DWORD *)(v6 + 28) = ReceiveCompletion;
        *(_DWORD *)(v6 + 32) = v4;
        *(_BYTE *)(v6 + 3) = -32;
      }
      else
      {
        v7 = (int)&v5[-9];
        *(_DWORD *)(v7 + 28) = 0;
        *(_DWORD *)(v7 + 32) = 0;
        *(_BYTE *)(v7 + 3) = 0;
      }
      v8 = (int)&v4[6].Next[24].Next[-9];
      *(_BYTE *)v8 = 15;
      *(_BYTE *)(v8 + 1) = 8;
      *(_DWORD *)(v8 + 20) = DeviceObject;
      *(_DWORD *)(v8 + 24) = v3;
      *(_DWORD *)(v8 + 8) = 0;
      *(_DWORD *)(v8 + 4) = 0;
      v4[6].Next[1].Next = v4[5].Next;
      IofCallDriver(DeviceObject, (PIRP)v4[6].Next);
    }
    ConnectionReleaseFileObject(v11, v3);
    ReleaseConnection((PKSPIN_LOCK)v11);
  }
  return 0;
}

//----- (0001400C) --------------------------------------------------------
signed int __stdcall IrdaConnect(int a1, int a2, const char *a3, char a4, int a5, int a6, int a7, int a8)
{
  PVOID v8; // eax@1
  int v9; // esi@1
  signed int result; // eax@2
  signed int v11; // [sp+10h] [bp-8h]@3

  *(_DWORD *)a5 = 0;
  v8 = ExAllocatePoolWithTag(0, 0x74u, DebugMemoryTag);
  v9 = (int)v8;
  if ( v8 )
  {
    memset(v8, 0, 0x74u);
    *(_DWORD *)(v9 + 28) = a8;
    *(_DWORD *)(v9 + 36) = a8;
    *(_DWORD *)(v9 + 32) = a7;
    *(_DWORD *)(v9 + 96) = 1;
    *(_DWORD *)(v9 + 100) = 1;
    *(_DWORD *)v9 = 1;
    *(_DWORD *)(v9 + 56) = 0;
    *(_DWORD *)(v9 + 68) = SendWorkItemRountine;
    *(_DWORD *)(v9 + 72) = v9;
    *(_DWORD *)(v9 + 60) = 0;
    *(_DWORD *)(v9 + 24) = a6;
    *(_DWORD *)(v9 + 104) = 115200;
    *(_BYTE *)(v9 + 110) = 8;
    *(_BYTE *)(v9 + 108) = 0;
    *(_BYTE *)(v9 + 109) = 0;
    *(_DWORD *)(v9 + 112) = 0;
    KeInitializeEvent((PRKEVENT)(v9 + 4), 0, 0);
    *(_DWORD *)a5 = v9;
    result = CreateTdiLink(a1, a2, a3, a4, v9 + 20, v9, (int)LinkReceiveHandler, (int)LinkStateHandler, 7, 3, 3);
    v11 = result;
    if ( result < 0 )
    {
      *(_DWORD *)a5 = 0;
      FreeConnection((PVOID)v9);
      result = v11;
    }
  }
  else
  {
    result = -1073741670;
  }
  return result;
}

//----- (00014100) --------------------------------------------------------
void __stdcall RemoveReferenceOnTracker(volatile LONG *Addend)
{
  if ( !InterlockedDecrement(Addend) )
  {
    RemoveRefereneToConnection(*((volatile LONG **)Addend + 28));
    ExFreePoolWithTag((PVOID)Addend, 0);
  }
}

//----- (00014130) --------------------------------------------------------
int __stdcall GetCurrentIrpAndAddReference(int a1)
{
  KIRQL v1; // al@1
  int v2; // edi@1

  v1 = KfAcquireSpinLock((PKSPIN_LOCK)(*(_DWORD *)(a1 + 112) + 56));
  v2 = *(_DWORD *)(a1 + 4);
  if ( v2 )
    ++*(_DWORD *)(a1 + 8);
  KfReleaseSpinLock((PKSPIN_LOCK)(*(_DWORD *)(a1 + 112) + 56), v1);
  return v2;
}

//----- (0001416C) --------------------------------------------------------
void __stdcall ReleaseIrpReference(volatile LONG *Addend)
{
  volatile LONG *v1; // esi@1
  int v2; // edi@1
  void (__stdcall *v3)(_DWORD, _DWORD); // ebx@1
  KIRQL v4; // al@1
  bool v5; // zf@1
  volatile LONG *v6; // ecx@2

  v1 = Addend;
  v2 = 0;
  v3 = 0;
  v4 = KfAcquireSpinLock((PKSPIN_LOCK)(*((_DWORD *)Addend + 28) + 56));
  v5 = *((_DWORD *)Addend + 2) == 1;
  --*((_DWORD *)v1 + 2);
  if ( v5 )
  {
    v6 = (volatile LONG *)*((_DWORD *)Addend + 3);
    v2 = *((_DWORD *)Addend + 1);
    *((_DWORD *)Addend + 1) = 0;
    v3 = (void (__stdcall *)(_DWORD, _DWORD))*((_DWORD *)Addend + 4);
    Addend = v6;
    *(_DWORD *)(*((_DWORD *)v1 + 28) + 48) = 0;
  }
  KfReleaseSpinLock((PKSPIN_LOCK)(*((_DWORD *)v1 + 28) + 56), v4);
  if ( v2 )
  {
    v3(Addend, v2);
    RemoveReferenceOnTracker(v1);
  }
}

//----- (000141CC) --------------------------------------------------------
int __stdcall SetIrpAndRefcounts(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = 2;
  *(_DWORD *)(a1 + 8) = 1;
  *(_DWORD *)(a1 + 4) = a2;
  return result;
}

//----- (000141F0) --------------------------------------------------------
void __stdcall TryToCompleteCurrentIrp(int NewIrql)
{
  int v1; // esi@1
  BOOLEAN v2; // bl@1
  int v3; // edi@1
  LONG v4; // [sp+Ch] [bp-4h]@1
  KIRQL v5; // [sp+1Bh] [bp+Bh]@1

  v4 = 0;
  v1 = NewIrql;
  v2 = 0;
  v3 = GetCurrentIrpAndAddReference(NewIrql);
  v5 = KfAcquireSpinLock((PKSPIN_LOCK)(*(_DWORD *)(NewIrql + 112) + 56));
  if ( *(_BYTE *)(v1 + 104) )
  {
    v2 = KeCancelTimer((PKTIMER)(v1 + 32));
    if ( v2 )
      *(_BYTE *)(v1 + 104) = 0;
  }
  if ( v3 )
    v4 = InterlockedExchange((volatile LONG *)(v3 + 56), 0);
  KfReleaseSpinLock((PKSPIN_LOCK)(*(_DWORD *)(v1 + 112) + 56), v5);
  if ( v2 )
    ReleaseIrpReference((volatile LONG *)v1);
  if ( v3 )
  {
    if ( v4 )
      ReleaseIrpReference((volatile LONG *)v1);
    ReleaseIrpReference((volatile LONG *)v1);
  }
}

//----- (00014280) --------------------------------------------------------
NTSTATUS __stdcall SendBufferToTdi(PFILE_OBJECT FileObject, int a2)
{
  struct _DEVICE_OBJECT *v2; // ebx@1
  int v3; // edx@1
  int v4; // eax@1
  int v5; // eax@2
  int v6; // eax@3
  int v7; // eax@4

  v2 = IoGetRelatedDeviceObject(FileObject);
  IoReuseIrp(*(PIRP *)(a2 + 24), 0);
  *(_DWORD *)(*(_DWORD *)(a2 + 24) + 100) = FileObject;
  v3 = *(_DWORD *)(*(_DWORD *)(a2 + 20) + 20);
  v4 = *(_DWORD *)(*(_DWORD *)(a2 + 24) + 96);
  if ( SendCompletion )
  {
    v5 = v4 - 36;
    *(_DWORD *)(v5 + 28) = SendCompletion;
    *(_DWORD *)(v5 + 32) = a2;
    *(_BYTE *)(v5 + 3) = -32;
  }
  else
  {
    *(_DWORD *)(v4 - 8) = 0;
    v6 = v4 - 36;
    *(_DWORD *)(v6 + 32) = 0;
    *(_BYTE *)(v6 + 3) = 0;
  }
  v7 = *(_DWORD *)(*(_DWORD *)(a2 + 24) + 96) - 36;
  *(_BYTE *)v7 = 15;
  *(_BYTE *)(v7 + 1) = 7;
  *(_DWORD *)(v7 + 20) = v2;
  *(_DWORD *)(v7 + 24) = FileObject;
  *(_DWORD *)(v7 + 8) = 0;
  *(_DWORD *)(v7 + 4) = v3;
  *(_DWORD *)(*(_DWORD *)(a2 + 24) + 4) = *(_DWORD *)(a2 + 20);
  return IofCallDriver(v2, *(PIRP *)(a2 + 24));
}

//----- (0001431A) --------------------------------------------------------
void __stdcall AbortSend(int a1)
{
  KIRQL v1; // al@1
  int v2; // esi@1
  KIRQL v3; // bl@1

  v1 = KfAcquireSpinLock((PKSPIN_LOCK)(a1 + 56));
  v2 = *(_DWORD *)(a1 + 48);
  v3 = v1;
  if ( v2 )
    InterlockedIncrement((volatile LONG *)v2);
  KfReleaseSpinLock((PKSPIN_LOCK)(a1 + 56), v3);
  if ( v2 )
  {
    TryToCompleteCurrentIrp(v2);
    RemoveReferenceOnTracker((volatile LONG *)v2);
  }
}

//----- (00014368) --------------------------------------------------------
void __stdcall SendTimerProc(struct _KDPC *Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2)
{
  int v4; // eax@1

  *((_BYTE *)DeferredContext + 104) = 0;
  v4 = GetCurrentIrpAndAddReference((int)DeferredContext);
  if ( v4 )
  {
    *(_DWORD *)(v4 + 24) = 258;
    ReleaseIrpReference((volatile LONG *)DeferredContext);
  }
  TryToCompleteCurrentIrp((int)DeferredContext);
  ReleaseIrpReference((volatile LONG *)DeferredContext);
}

//----- (000143A2) --------------------------------------------------------
void __stdcall SendCancelRoutine(int a1, int a2)
{
  int v2; // edi@1

  v2 = *(_DWORD *)(a2 + 64);
  IoReleaseCancelSpinLock(*(_BYTE *)(a2 + 37));
  *(_DWORD *)(a2 + 24) = -1073741536;
  TryToCompleteCurrentIrp(v2);
  ReleaseIrpReference((volatile LONG *)v2);
}

//----- (000143D8) --------------------------------------------------------
void __stdcall ProcessSend(int NewIrql)
{
  int v1; // ebx@1
  int v2; // esi@1
  bool v3; // zf@2
  int v4; // edi@5
  int v5; // eax@6
  int v6; // eax@7
  int v7; // esi@7
  PSINGLE_LIST_ENTRY v8; // eax@8
  int v9; // esi@8
  int v10; // eax@9
  int v11; // [sp+8h] [bp-10h]@6
  int v12; // [sp+Ch] [bp-Ch]@7
  int v13; // [sp+10h] [bp-8h]@7
  struct _FILE_OBJECT *Object; // [sp+14h] [bp-4h]@8
  size_t NewIrqla; // [sp+20h] [bp+8h]@9
  KIRQL v16; // [sp+23h] [bp+Bh]@1

  v1 = NewIrql;
  v2 = NewIrql + 56;
  v16 = KfAcquireSpinLock((PKSPIN_LOCK)(NewIrql + 56));
  if ( !*(_DWORD *)(v1 + 52) )
  {
    v3 = *(_DWORD *)(v1 + 48) == 0;
    *(_DWORD *)(v1 + 52) = 1;
    if ( !v3 )
    {
      do
      {
        if ( *(_BYTE *)(v1 + 80) )
          break;
        if ( !*(_BYTE *)(v1 + 44) )
          break;
        v4 = *(_DWORD *)(v1 + 48);
        if ( *(_DWORD *)(v4 + 24) <= 0 )
          break;
        InterlockedIncrement(*(volatile LONG **)(v1 + 48));
        KfReleaseSpinLock((PKSPIN_LOCK)v2, v16);
        v5 = GetCurrentIrpAndAddReference(v4);
        v11 = v5;
        if ( v5 )
        {
          v12 = *(_DWORD *)(v5 + 96);
          v6 = (int)GetCurrentConnection(*(PKSPIN_LOCK *)(v1 + 20));
          v7 = v6;
          v13 = v6;
          if ( v6 )
          {
            Object = (struct _FILE_OBJECT *)ConnectionGetFileObject(v6);
            v8 = ConnectionGetBuffer(v7, 0);
            v9 = (int)v8;
            if ( v8 )
            {
              v10 = (int)((char *)&v8[7].Next[-1].Next + 3);
              NewIrqla = *(_DWORD *)(v4 + 24);
              if ( *(_DWORD *)(v4 + 24) >= v10 )
                NewIrqla = v10;
              InterlockedIncrement((volatile LONG *)(v4 + 20));
              *(_BYTE *)(v9 + 32) = 0;
              memcpy(
                (void *)(v9 + 33),
                (const void *)(*(_DWORD *)(v11 + 12) + *(_DWORD *)(v12 + 4) - *(_DWORD *)(v4 + 24)),
                NewIrqla);
              *(_DWORD *)(*(_DWORD *)(v9 + 20) + 20) = NewIrqla + 1;
              InterlockedExchangeAdd((volatile LONG *)(v4 + 24), -NewIrqla);
              **(_DWORD **)(v9 + 20) = 0;
              *(_DWORD *)(v9 + 12) = v4;
              InterlockedIncrement((volatile LONG *)v4);
              SendBufferToTdi(Object, v9);
            }
            else
            {
              *(_BYTE *)(v1 + 80) = 1;
            }
            ConnectionReleaseFileObject(v13, Object);
            ReleaseConnection((PKSPIN_LOCK)v13);
          }
          else
          {
            *(_BYTE *)(v1 + 44) = 0;
          }
          ReleaseIrpReference((volatile LONG *)v4);
        }
        RemoveReferenceOnTracker((volatile LONG *)v4);
        v2 = v1 + 56;
        v16 = KfAcquireSpinLock((PKSPIN_LOCK)(v1 + 56));
      }
      while ( *(_DWORD *)(v1 + 48) );
    }
    --*(_DWORD *)(v1 + 52);
  }
  KfReleaseSpinLock((PKSPIN_LOCK)v2, v16);
}

//----- (00014550) --------------------------------------------------------
void __stdcall ProcessSendAtPassive(int NewIrql)
{
  if ( KeGetCurrentIrql() >= 2u )
  {
    if ( InterlockedIncrement((volatile LONG *)(NewIrql + 76)) == 1 )
      ExQueueWorkItem((PWORK_QUEUE_ITEM)(NewIrql + 60), 0);
  }
  else
  {
    ProcessSend(NewIrql);
  }
}

//----- (0001458E) --------------------------------------------------------
void __stdcall SendWorkItemRountine(int NewIrql)
{
  InterlockedExchange((volatile LONG *)(NewIrql + 76), 0);
  ProcessSend(NewIrql);
}

//----- (000145B2) --------------------------------------------------------
signed int __stdcall SendCompletion(int a1, int a2, int a3)
{
  int v3; // esi@1
  int v4; // edi@1
  int v5; // eax@3

  v3 = *(_DWORD *)(a3 + 12);
  v4 = *(_DWORD *)(v3 + 112);
  *(_DWORD *)(v3 + 108) = *(_DWORD *)(a2 + 24);
  (*(void (__stdcall **)(int))(a3 + 8))(a3);
  *(_BYTE *)(v4 + 80) = 0;
  if ( !InterlockedDecrement((volatile LONG *)(v3 + 20)) && !*(_DWORD *)(v3 + 24) )
  {
    v5 = GetCurrentIrpAndAddReference(v3);
    if ( v5 )
    {
      *(_DWORD *)(v5 + 28) = *(_DWORD *)(*(_DWORD *)(v5 + 96) + 4);
      *(_DWORD *)(v5 + 24) = *(_DWORD *)(v3 + 108);
      ReleaseIrpReference((volatile LONG *)v3);
      TryToCompleteCurrentIrp(v3);
    }
  }
  RemoveReferenceOnTracker((volatile LONG *)v3);
  ProcessSendAtPassive(v4);
  return -1073741802;
}

//----- (00014626) --------------------------------------------------------
void __stdcall SendOnConnection(volatile LONG *Addend, int a2, int a3, int NewIrql, int a5)
{
  int v5; // ebx@1
  int v6; // edi@1
  bool v7; // zf@1
  PVOID v8; // eax@3
  int v9; // esi@3
  int v10; // ST08_4@4
  int v11; // eax@5
  int v12; // eax@5
  int v13; // eax@7

  v5 = a2;
  v6 = (int)Addend;
  v7 = *((_DWORD *)Addend + 12) == 0;
  a2 = *(_DWORD *)(a2 + 96);
  if ( v7 )
  {
    v8 = ExAllocatePoolWithTag(0, 0x78u, DebugMemoryTag);
    v9 = (int)v8;
    if ( v8 )
    {
      memset(v8, 0, 0x78u);
      KeInitializeTimer((PKTIMER)(v9 + 32));
      KeInitializeDpc((PRKDPC)(v9 + 72), SendTimerProc, (PVOID)v9);
      SetIrpAndRefcounts(v9, v5);
      InterlockedIncrement((volatile LONG *)v6);
      v11 = NewIrql;
      *(_DWORD *)(v9 + 20) = 0;
      v7 = a5 == 0;
      *(_DWORD *)(v9 + 12) = v11;
      *(_DWORD *)(v9 + 16) = a3;
      v12 = a2;
      *(_DWORD *)(v9 + 112) = v6;
      *(_DWORD *)(v9 + 24) = *(_DWORD *)(v12 + 4);
      if ( !v7 )
        GetCurrentIrpAndAddReference(v9);
      GetCurrentIrpAndAddReference(v9);
      BYTE3(NewIrql) = KfAcquireSpinLock((PKSPIN_LOCK)(v6 + 56));
      v13 = a5;
      *(_DWORD *)(v6 + 48) = v9;
      if ( v13 )
      {
        *(_BYTE *)(v9 + 104) = 1;
        KeSetTimer((PKTIMER)(v9 + 32), (LARGE_INTEGER)(-10000i64 * (unsigned int)(v13 + 100)), (PKDPC)(v9 + 72));
      }
      *(_DWORD *)(v5 + 64) = v9;
      IoAcquireCancelSpinLock((PKIRQL)&Addend);
      BYTE3(a3) = *(_BYTE *)(v5 + 36);
      if ( BYTE3(a3) )
        *(_DWORD *)(v5 + 24) = -1073741536;
      else
        InterlockedExchange((volatile LONG *)(v5 + 56), (LONG)SendCancelRoutine);
      IoReleaseCancelSpinLock((KIRQL)Addend);
      KfReleaseSpinLock((PKSPIN_LOCK)(v6 + 56), BYTE3(NewIrql));
      if ( BYTE3(a3) )
      {
        IoAcquireCancelSpinLock((PKIRQL)(v5 + 37));
        SendCancelRoutine(0, v5);
      }
      ReleaseIrpReference((volatile LONG *)v9);
      ProcessSendAtPassive(v6);
      RemoveReferenceOnTracker((volatile LONG *)v9);
    }
    else
    {
      v10 = NewIrql;
      *(_DWORD *)(v5 + 24) = -1073741670;
      ((void (__stdcall *)(int, int))a3)(v10, v5);
    }
  }
  else
  {
    ((void (__stdcall *)(int, int))a3)(NewIrql, v5);
  }
}

//----- (0001478E) --------------------------------------------------------
LONG __stdcall UartStateCompletion(volatile LONG *Addend, int a2)
{
  int v2; // eax@1
  int v3; // edx@1
  void (__stdcall *v4)(_DWORD, _DWORD); // ecx@1

  v2 = *((_DWORD *)Addend + 21);
  v3 = *((_DWORD *)Addend + 22);
  v4 = (void (__stdcall *)(_DWORD, _DWORD))*((_DWORD *)Addend + 23);
  *((_DWORD *)Addend + 23) = 0;
  *(_DWORD *)(v2 + 24) = a2;
  v4(v3, v2);
  return RemoveRefereneToConnection(Addend);
}

//----- (000147C0) --------------------------------------------------------
signed int __stdcall SendControlIrpCompletionRoutine(int a1, int a2, int a3)
{
  int v3; // ebx@1
  void (__stdcall *v4)(_DWORD, _DWORD); // esi@1
  int v5; // edi@1

  v3 = *(_DWORD *)(a2 + 24);
  v4 = *(void (__stdcall **)(_DWORD, _DWORD))(a3 + 16);
  v5 = *(_DWORD *)(a3 + 12);
  (*(void (__stdcall **)(int))(a3 + 8))(a3);
  v4(v5, v3);
  return -1073741802;
}

//----- (000147F0) --------------------------------------------------------
LONG_PTR __stdcall SendControlInfo(int a1, int a2, int a3, char a4, char a5, void *a6)
{
  LONG_PTR result; // eax@2
  PSINGLE_LIST_ENTRY v7; // esi@3
  struct _FILE_OBJECT *v8; // edi@5
  struct _SINGLE_LIST_ENTRY *v9; // ecx@5
  struct _DEVICE_OBJECT *v10; // ebx@5
  struct _SINGLE_LIST_ENTRY *v11; // edx@5
  struct _SINGLE_LIST_ENTRY *v12; // eax@5
  int v13; // eax@6
  int v14; // eax@7
  int v15; // eax@8

  if ( a1 )
  {
    v7 = ConnectionGetBuffer(a1, 1);
    if ( v7 && v7[7].Next >= (struct _SINGLE_LIST_ENTRY *)((unsigned __int8)a5 + 3) )
    {
      v8 = (struct _FILE_OBJECT *)ConnectionGetFileObject(a1);
      BYTE1(v7[8].Next) = a4;
      BYTE2(v7[8].Next) = a5;
      memcpy((char *)&v7[8].Next + 3, a6, (unsigned __int8)a5);
      v9 = v7[5].Next;
      LOBYTE(v7[8].Next) = a5 + 2;
      v9[5].Next = (struct _SINGLE_LIST_ENTRY *)((unsigned __int8)(a5 + 2) + 1);
      v7[3].Next = (struct _SINGLE_LIST_ENTRY *)a3;
      v7[4].Next = (struct _SINGLE_LIST_ENTRY *)a2;
      v10 = IoGetRelatedDeviceObject(v8);
      IoReuseIrp((PIRP)v7[6].Next, 0);
      v7[6].Next[25].Next = (struct _SINGLE_LIST_ENTRY *)v8;
      v11 = v7[5].Next[5].Next;
      v12 = v7[6].Next[24].Next;
      if ( SendControlIrpCompletionRoutine )
      {
        v13 = (int)&v12[-9];
        *(_DWORD *)(v13 + 28) = SendControlIrpCompletionRoutine;
        *(_DWORD *)(v13 + 32) = v7;
        *(_BYTE *)(v13 + 3) = -32;
      }
      else
      {
        v12[-2].Next = 0;
        v14 = (int)&v12[-9];
        *(_DWORD *)(v14 + 32) = 0;
        *(_BYTE *)(v14 + 3) = 0;
      }
      v15 = (int)&v7[6].Next[24].Next[-9];
      *(_BYTE *)v15 = 15;
      *(_BYTE *)(v15 + 1) = 7;
      *(_DWORD *)(v15 + 20) = v10;
      *(_DWORD *)(v15 + 24) = v8;
      *(_DWORD *)(v15 + 8) = 0;
      *(_DWORD *)(v15 + 4) = v11;
      v7[6].Next[1].Next = v7[5].Next;
      IofCallDriver(v10, (PIRP)v7[6].Next);
      result = ConnectionReleaseFileObject(a1, v8);
    }
    else
    {
      result = ((int (__stdcall *)(_DWORD, _DWORD))a2)(a3, -1073741670);
    }
  }
  else
  {
    result = ((int (__stdcall *)(_DWORD, _DWORD))a2)(a3, 0);
  }
  return result;
}

//----- (00014916) --------------------------------------------------------
LONG __stdcall SetEventCompletion(PRKEVENT Event, int a2)
{
  Event[1].Header.Lock = a2;
  return KeSetEvent(Event, 0, 0);
}

//----- (00014938) --------------------------------------------------------
int __stdcall SendSynchronousControlInfo(int a1, char a2, char a3, void *a4)
{
  struct _KEVENT Event; // [sp+4h] [bp-14h]@1
  int v6; // [sp+14h] [bp-4h]@1

  KeInitializeEvent(&Event, 0, 0);
  SendControlInfo(a1, (int)SetEventCompletion, (int)&Event, a2, a3, a4);
  KeWaitForSingleObject(&Event, 0, 0, 0, 0);
  return v6;
}

//----- (00014984) --------------------------------------------------------
void __stdcall AccessUartState(volatile LONG *Addend, int a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // esi@1
  int v6; // eax@1
  int v7; // edi@1
  int v8; // ST28_4@1
  KSPIN_LOCK *v9; // ST14_4@1
  int v10; // eax@1
  unsigned int v11; // ecx@1
  LONG v12; // edi@8
  char v13; // al@9
  LONG v14; // edi@10
  char v15; // al@11
  char v16; // cl@19
  char v17; // dl@19
  char v18; // al@19
  unsigned int v19; // eax@22
  int v20; // ecx@24
  int v21; // ecx@25
  int v22; // ecx@26
  int v23; // ecx@29
  int v24; // eax@32
  int v25; // [sp+Ch] [bp-Ch]@1
  signed int v26; // [sp+14h] [bp-4h]@1
  KSPIN_LOCK *Addenda; // [sp+20h] [bp+8h]@1

  v26 = 0;
  v4 = (int)Addend;
  v5 = a2;
  v6 = *(_DWORD *)(a2 + 96);
  *(_DWORD *)(a2 + 28) = 0;
  v7 = *(_DWORD *)(v5 + 12);
  v8 = v6;
  v25 = *(_DWORD *)(v5 + 12);
  InterlockedIncrement(Addend);
  v9 = (KSPIN_LOCK *)*((_DWORD *)Addend + 5);
  *((_DWORD *)Addend + 22) = a4;
  v10 = a3;
  *((_DWORD *)Addend + 21) = v5;
  *((_DWORD *)Addend + 23) = v10;
  Addenda = GetCurrentConnection(v9);
  v11 = *(_DWORD *)(v8 + 12);
  if ( v11 > 0x1B0034 )
  {
    v20 = v11 - 1769552;
    if ( v20 )
    {
      v21 = v20 - 4;
      if ( v21 )
      {
        v22 = v21 - 20;
        if ( v22 )
        {
          if ( v22 != 16 )
            goto LABEL_28;
          v23 = *(_DWORD *)(v4 + 96) != 0;
          *(_DWORD *)v7 = v23;
          *(_DWORD *)v7 = v23 | (*(_DWORD *)(v4 + 100) != 0 ? 2 : 0);
        }
        else
        {
          *(_DWORD *)v7 = *(_DWORD *)(v4 + 112);
        }
        *(_DWORD *)(v5 + 28) = 4;
      }
      else
      {
        v24 = a2;
        *(_WORD *)v7 = *(_WORD *)(v4 + 108);
        *(_BYTE *)(v7 + 2) = *(_BYTE *)(v4 + 110);
        *(_DWORD *)(v24 + 28) = 3;
        v5 = v24;
      }
    }
    else
    {
      *(_DWORD *)v7 = *(_DWORD *)(v4 + 104);
      *(_DWORD *)(v5 + 28) = 4;
    }
    v26 = 0;
    goto LABEL_35;
  }
  if ( v11 == 1769524 )
    goto LABEL_8;
  if ( v11 == 1769476 )
  {
    v19 = *(_DWORD *)v7;
    if ( *(_DWORD *)v7 == *(_DWORD *)(v4 + 104) )
      goto LABEL_35;
    LOBYTE(a2) = *(_DWORD *)v7 >> 24;
    BYTE1(a2) = v19 >> 16;
    *(_DWORD *)(v4 + 104) = v19;
    BYTE2(a2) = BYTE1(v19);
    BYTE3(a2) = v19;
    SendControlInfo((int)Addenda, (int)UartStateCompletion, v4, 16, 4, &a2);
  }
  else
  {
    if ( v11 != 1769484 )
    {
      if ( v11 == 1769508 || v11 == 1769512 )
      {
        v14 = v11 == 1769508;
        if ( v14 != InterlockedExchange((volatile LONG *)(v4 + 96), v14) )
        {
          v15 = (*(_DWORD *)(v4 + 100) == 0 ? 0 : 8) | 1;
          BYTE3(a2) = (*(_DWORD *)(v4 + 100) == 0 ? 0 : 8) | 1;
          if ( !v14 )
          {
LABEL_14:
            SendControlInfo((int)Addenda, (int)UartStateCompletion, v4, 32, 1, (char *)&a2 + 3);
            goto LABEL_36;
          }
          v13 = v15 | 4;
LABEL_13:
          BYTE3(a2) = v13;
          goto LABEL_14;
        }
LABEL_35:
        *(_DWORD *)(v5 + 24) = v26;
        UartStateCompletion((volatile LONG *)v4, v26);
        goto LABEL_36;
      }
      if ( v11 == 1769520 )
      {
LABEL_8:
        v12 = v11 == 1769520;
        if ( v12 != InterlockedExchange((volatile LONG *)(v4 + 100), v12) )
        {
          v13 = (v12 == 0 ? 0 : 8) | (*(_DWORD *)(v4 + 96) == 0 ? 0 : 4) | 2;
          goto LABEL_13;
        }
        goto LABEL_35;
      }
LABEL_28:
      v26 = -1073741823;
      goto LABEL_35;
    }
    if ( *(_BYTE *)v7 == *(_BYTE *)(v4 + 108)
      && *(_BYTE *)(v7 + 1) == *(_BYTE *)(v4 + 109)
      && *(_BYTE *)(v7 + 2) == *(_BYTE *)(v4 + 110) )
      goto LABEL_35;
    *(_WORD *)(v4 + 108) = *(_WORD *)v7;
    *(_BYTE *)(v4 + 110) = *(_BYTE *)(v7 + 2);
    v16 = *(_BYTE *)(v25 + 1);
    v17 = *(_BYTE *)v25 == 0 ? 0 : 4;
    v18 = v17 | (v16 == 0 ? 0 : 8) | (*(_BYTE *)(v25 + 2) - 1) & 3;
    BYTE3(a2) = v17 | (v16 == 0 ? 0 : 8) | (*(_BYTE *)(v25 + 2) - 1) & 3;
    if ( v16 )
      BYTE3(a2) = 16 * ((v16 - 1) & 3) | v18;
    SendControlInfo((int)Addenda, (int)UartStateCompletion, v4, 17, 1, (char *)&a2 + 3);
  }
LABEL_36:
  if ( Addenda )
    ReleaseConnection(Addenda);
}

//----- (00014BDC) --------------------------------------------------------
void __cdecl __noreturn __report_gsfailure()
{
  ULONG_PTR v0; // ecx@0
  ULONG_PTR v1; // [sp-Ch] [bp-10h]@0

  KeBugCheckEx(0xF7u, v0, v1, __security_cookie_complement, 0);
}

//----- (0001700E) --------------------------------------------------------
NTSTATUS __stdcall WaitForLowerDriverToCompleteIrp(PDEVICE_OBJECT DeviceObject, PIRP Irp, char a3)
{
  struct _IRP::$::$::$::$A02EC6A2CE86544F716F4825015773AC::_IO_STACK_LOCATION *v3; // esi@2
  ULONG v4; // eax@3
  struct _KEVENT Event; // [sp+8h] [bp-10h]@1

  KeInitializeEvent(&Event, 0, 0);
  if ( a3 )
  {
    v3 = Irp->Tail.Overlay.CurrentStackLocation;
    qmemcpy((char *)v3 - 36, (const void *)v3, 0x1Cu);
    *((_BYTE *)v3 - 33) = 0;
  }
  v4 = Irp->Tail.Overlay.PacketType - 36;
  *(_DWORD *)(v4 + 32) = &Event;
  *(_DWORD *)(v4 + 28) = IoCompletionSetEvent;
  *(_BYTE *)(v4 + 3) = -32;
  if ( IofCallDriver(DeviceObject, Irp) == 259 )
    KeWaitForSingleObject(&Event, 0, 0, 0, 0);
  return Irp->IoStatus.Status;
}

//----- (0001708A) --------------------------------------------------------
void __stdcall InitializePacketQueue(void *a1, int a2, int a3)
{
  void *v3; // esi@1

  v3 = a1;
  memset(a1, 0, 0x2Cu);
  *((_DWORD *)a1 + 4) = 0;
  *((_DWORD *)a1 + 5) = a2;
  *((_DWORD *)a1 + 6) = a3;
  *((_BYTE *)a1 + 12) = 1;
  KeInitializeEvent((PRKEVENT)((char *)a1 + 28), 0, 0);
  *((_DWORD *)v3 + 1) = v3;
  *(_DWORD *)v3 = v3;
}

//----- (00018006) --------------------------------------------------------
NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
  USHORT v2; // ax@1
  NTSTATUS result; // eax@2
  PVOID v4; // edi@3
  struct _RTL_QUERY_REGISTRY_TABLE QueryTable; // [sp+8h] [bp-84h]@5
  int v6; // [sp+28h] [bp-64h]@5
  int v7; // [sp+2Ch] [bp-60h]@5
  int *v8; // [sp+30h] [bp-5Ch]@5
  int v9; // [sp+34h] [bp-58h]@5
  int *v10; // [sp+38h] [bp-54h]@5
  int v11; // [sp+3Ch] [bp-50h]@5
  int v12; // [sp+78h] [bp-14h]@3
  int v13; // [sp+80h] [bp-Ch]@1
  int v14; // [sp+84h] [bp-8h]@1
  int v15; // [sp+88h] [bp-4h]@1

  v2 = RegistryPath->Length;
  v14 = 0;
  v13 = 0;
  v15 = 0;
  if ( v2 < 0xFFFDu )
  {
    LOWORD(v12) = v2;
    v4 = ExAllocatePoolWithTag(PagedPool, (unsigned __int16)(v2 + 2), DebugMemoryTag);
    if ( v4 )
    {
      memcpy(v4, RegistryPath->Buffer, RegistryPath->Length);
      *((_WORD *)v4 + ((unsigned int)RegistryPath->Length >> 1)) = 0;
      memset(&QueryTable, 0, 0x70u);
      QueryTable.EntryContext = &v15;
      QueryTable.DefaultType = 4;
      QueryTable.DefaultLength = 4;
      v9 = 4;
      v11 = 4;
      QueryTable.Flags = 32;
      v6 = 32;
      v8 = &v13;
      QueryTable.Name = L"BreakOnEntry";
      QueryTable.DefaultData = &v14;
      v7 = (int)L"DebugFlags";
      v10 = &v14;
      if ( RtlQueryRegistryValues(0x80000000, (PCWSTR)v4, &QueryTable, 0, 0) < 0 )
        v15 = 0;
      if ( v15 )
        __debugbreak();
      DriverObject->DriverExtension->AddDevice = IrCommAddDevice;
      DriverObject->DriverUnload = (PDRIVER_UNLOAD)IrCommUnload;
      DriverObject->MajorFunction[27] = IrCommPnP;
      DriverObject->MajorFunction[22] = (PDRIVER_DISPATCH)IrCommPower;
      DriverObject->MajorFunction[23] = (PDRIVER_DISPATCH)IrCommWmi;
      DriverObject->MajorFunction[0] = (PDRIVER_DISPATCH)IrCommCreate;
      DriverObject->MajorFunction[2] = (PDRIVER_DISPATCH)IrCommClose;
      DriverObject->MajorFunction[4] = (PDRIVER_DISPATCH)IrCommWrite;
      DriverObject->MajorFunction[3] = (PDRIVER_DISPATCH)IrCommRead;
      DriverObject->MajorFunction[14] = (PDRIVER_DISPATCH)IrCommDeviceControl;
      DriverObject->MajorFunction[18] = (PDRIVER_DISPATCH)IrCommCleanup;
      DriverObject->MajorFunction[5] = (PDRIVER_DISPATCH)IrCommQueryInformation;
      DriverObject->MajorFunction[6] = (PDRIVER_DISPATCH)IrCommQueryInformation;
      PagedCodeSectionHandle = (int)MmLockPagableDataSection(IrCommUnload);
      MmUnlockPagableImageSection((PVOID)PagedCodeSectionHandle);
      ExFreePoolWithTag(v4, 0);
      result = 0;
    }
    else
    {
      result = -1073741670;
    }
  }
  else
  {
    result = -1073741670;
  }
  return result;
}
// 1600C: using guessed type int PagedCodeSectionHandle;
// 17006: using guessed type int __stdcall IrCommUnload(int);
// 181CC: using guessed type wchar_t aDebugflags[11];
// 181E2: using guessed type wchar_t aBreakonentry[13];

//----- (00018182) --------------------------------------------------------
void __cdecl __security_init_cookie()
{
  ULONG v0; // eax@1

  v0 = __security_cookie;
  if ( !__security_cookie || __security_cookie == -1153374642 )
  {
    v0 = (unsigned int)&__security_cookie ^ _KeTickCount.LowPart;
    __security_cookie = (unsigned int)&__security_cookie ^ _KeTickCount.LowPart;
    if ( &__security_cookie == (ULONG_PTR *)_KeTickCount.LowPart )
    {
      v0 = -1153374642;
      __security_cookie = -1153374642;
    }
  }
  __security_cookie_complement = ~v0;
}

//----- (000181BB) --------------------------------------------------------
NTSTATUS __stdcall GsDriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
  __security_init_cookie();
  JUMPOUT(DriverEntry);
}

// ALL OK, 108 function(s) have been successfully decompiled
