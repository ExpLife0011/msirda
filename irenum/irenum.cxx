/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2014 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

// signed int __userpurge RtlStringCbCallback@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4, int a5);
NTSTATUS __stdcall RtlStringCbCopyW(wchar_t *pszDest, size_t cbDest, const wchar_t *pszSrc);
NTSTATUS __stdcall RtlStringCbCatW(wchar_t *pszDest, size_t cbDest, const wchar_t *pszSrc);
NTSTATUS __stdcall UnHandledDispatch(int a1, PIRP Irp);
NTSTATUS __stdcall ForwardIrp(PDEVICE_OBJECT DeviceObject, PIRP Irp);
NTSTATUS RtlStringCbPrintfA(char *pszDest, size_t cbDest, const char *pszFormat, ...);
signed int __stdcall CreateEnumObject(int a1, int a2, char a3);
// void *__cdecl memcpy(void *, const void *, size_t);
// void *__cdecl memset(void *, int, size_t);
// ULONG DbgPrint(PCH Format, ...);
NTSTATUS __stdcall IrdaOpenControlChannel(PHANDLE FileHandle);
NTSTATUS __stdcall IrdaLazyDiscoverDevices(HANDLE FileHandle, HANDLE Event, PIO_STATUS_BLOCK IoStatusBlock, PVOID OutputBuffer, ULONG OutputBufferLength);
HRESULT __stdcall StringCbCopyA(STRSAFE_LPSTR pszDest, size_t cbDest, STRSAFE_LPCSTR pszSrc);
NTSTATUS __stdcall IrdaIASStringQuery(int a1, STRSAFE_LPCSTR pszSrc, STRSAFE_LPCSTR a3, int a4);
NTSTATUS __stdcall IrdaIASIntegerQuery(int a1, STRSAFE_LPCSTR pszSrc, STRSAFE_LPCSTR a3, int a4);
// void __fastcall IofCompleteRequest(PIRP Irp, CCHAR PriorityBoost);
// void __stdcall PoStartNextPowerIrp(PIRP Irp);
// LONG_PTR __fastcall ObfReferenceObject(PVOID Object);
// PVOID __stdcall ExAllocatePoolWithTag(POOL_TYPE PoolType, SIZE_T NumberOfBytes, ULONG Tag);
// NTSTATUS __stdcall ZwClose(HANDLE Handle);
// NTSTATUS __stdcall ZwSetValueKey(HANDLE KeyHandle, PUNICODE_STRING ValueName, ULONG TitleIndex, ULONG Type, PVOID Data, ULONG DataSize);
// void __stdcall RtlInitUnicodeString(PUNICODE_STRING DestinationString, PCWSTR SourceString);
// NTSTATUS __stdcall IoOpenDeviceRegistryKey(PDEVICE_OBJECT DeviceObject, ULONG DevInstKeyType, ACCESS_MASK DesiredAccess, PHANDLE DevInstRegKey);
// void __stdcall ExFreePoolWithTag(PVOID P, ULONG Tag);
// NTSTATUS __fastcall IofCallDriver(PDEVICE_OBJECT DeviceObject, PIRP Irp);
// void __stdcall MmUnlockPagableImageSection(PVOID ImageSectionHandle);
// PVOID __stdcall MmLockPagableDataSection(PVOID AddressWithinSection);
// NTSTATUS __stdcall RtlQueryRegistryValues(ULONG RelativeTo, PCWSTR Path, PRTL_QUERY_REGISTRY_TABLE QueryTable, PVOID Context, PVOID Environment);
// void __stdcall IoDeleteDevice(PDEVICE_OBJECT DeviceObject);
// void __stdcall IoDetachDevice(PDEVICE_OBJECT TargetDevice);
// PDEVICE_OBJECT __stdcall IoAttachDeviceToDeviceStack(PDEVICE_OBJECT SourceDevice, PDEVICE_OBJECT TargetDevice);
// NTSTATUS __stdcall IoCreateDevice(PDRIVER_OBJECT DriverObject, ULONG DeviceExtensionSize, PUNICODE_STRING DeviceName, ULONG DeviceType, ULONG DeviceCharacteristics, BOOLEAN Exclusive, PDEVICE_OBJECT *DeviceObject);
// NTSTATUS __stdcall PoCallDriver(PDEVICE_OBJECT DeviceObject, PIRP Irp);
// LONG __stdcall KeSetEvent(PRKEVENT Event, KPRIORITY Increment, BOOLEAN Wait);
// NTSTATUS __stdcall KeWaitForSingleObject(PVOID Object, KWAIT_REASON WaitReason, KPROCESSOR_MODE WaitMode, BOOLEAN Alertable, PLARGE_INTEGER Timeout);
// void __stdcall KeInitializeEvent(PRKEVENT Event, EVENT_TYPE Type, BOOLEAN State);
// NTSTATUS __stdcall RtlAnsiStringToUnicodeString(PUNICODE_STRING DestinationString, PCANSI_STRING SourceString, BOOLEAN AllocateDestinationString);
// void __stdcall RtlInitAnsiString(PANSI_STRING DestinationString, PCSZ SourceString);
// NTSTATUS __stdcall RtlAppendUnicodeToString(PUNICODE_STRING Destination, PCWSTR Source);
// int __cdecl __vsnprintf(char *, size_t, const char *, va_list);
// LONG_PTR __fastcall ObfDereferenceObject(PVOID Object);
// void __stdcall IoInvalidateDeviceRelations(PDEVICE_OBJECT DeviceObject, DEVICE_RELATION_TYPE Type);
// NTSTATUS __stdcall PsTerminateSystemThread(NTSTATUS ExitStatus);
// BOOLEAN __stdcall KeCancelTimer(PKTIMER);
// LONG __stdcall KeResetEvent(PRKEVENT Event);
// NTSTATUS __stdcall KeWaitForMultipleObjects(ULONG Count, PVOID *Object, WAIT_TYPE WaitType, KWAIT_REASON WaitReason, KPROCESSOR_MODE WaitMode, BOOLEAN Alertable, PLARGE_INTEGER Timeout, PKWAIT_BLOCK WaitBlockArray);
// BOOLEAN __stdcall KeSetTimer(PKTIMER Timer, LARGE_INTEGER DueTime, PKDPC Dpc);
// void __stdcall KeClearEvent(PRKEVENT Event);
// NTSTATUS __stdcall ObReferenceObjectByHandle(HANDLE Handle, ACCESS_MASK DesiredAccess, POBJECT_TYPE ObjectType, KPROCESSOR_MODE AccessMode, PVOID *Object, POBJECT_HANDLE_INFORMATION HandleInformation);
// NTSTATUS __stdcall PsCreateSystemThread(PHANDLE ThreadHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PCLIENT_ID ClientId, PKSTART_ROUTINE StartRoutine, PVOID StartContext);
// PKEVENT __stdcall IoCreateNotificationEvent(PUNICODE_STRING EventName, PHANDLE EventHandle);
// void __stdcall KeInitializeTimerEx(PKTIMER Timer, TIMER_TYPE Type);
// NTSTATUS __stdcall ZwCreateFile(PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength);
// NTSTATUS __stdcall ZwWaitForSingleObject(HANDLE Handle, BOOLEAN Alertable, PLARGE_INTEGER Timeout);
// NTSTATUS __stdcall ZwDeviceIoControlFile(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);
NTSTATUS __stdcall IrEnumPdoWmi(int a1, PIRP Irp);
NTSTATUS __stdcall IrEnumPdoPower(int a1, PIRP Irp);
int __stdcall IrEnumPdoPnp(PDEVICE_OBJECT DeviceObject, PIRP Irp); // idb
void __stdcall IrEnumUnload(int a1);
int __stdcall IrEnumAddDevice(PDRIVER_OBJECT DriverObject, PDEVICE_OBJECT TargetDevice); // idb
int __stdcall IrEnumPnP(PDEVICE_OBJECT DeviceObject, PIRP Irp); // idb
NTSTATUS __stdcall IrEnumPower(int a1, PIRP Irp);
NTSTATUS __stdcall IrEnumWmi(int a1, PIRP Irp);
NTSTATUS __stdcall DeviceNameFromDeviceInfo(int a1, WCHAR *a2, int a3);
NTSTATUS __stdcall CreatePdo(PDEVICE_OBJECT DeviceObject, int a2);
int __stdcall FixupDeviceId(int a1);
signed int __stdcall GetDeviceList(int a1, int a2);
LONG __stdcall RemoveDevice(int a1, void *a2);
NTSTATUS __stdcall CreateStaticDevice(int a1);
void __stdcall CloseEnumObject(PVOID P);
signed int __stdcall DoIasQueries(int a1);
NTSTATUS __stdcall EnumIrda(int a1);
void __stdcall WorkerThread(PVOID StartContext);
NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath);
void __cdecl __security_init_cookie();

//-------------------------------------------------------------------------
// Data declarations

// extern volatile KSYSTEM_TIME _KeTickCount;
GUID GUID_BUS_TYPE_IRDA = { 2061598145u, 51524u, 17622u, { 136u, 31u, 76u, 46u, 97u, 5u, 59u, 193u } };
ULONG DebugMemoryTag = 1850045001u; // idb
ULONG_PTR __security_cookie = 3141592654u; // idb
ULONG_PTR __security_cookie_complement = 1153374641u; // idb
int EnumStaticDevice = 0; // weak
int DriverEntryRegPath = 0; // weak
PVOID Path = NULL; // idb
int PagedCodeSectionHandle = 0; // weak


//----- (00011006) --------------------------------------------------------
signed int __userpurge RtlStringCbCallback@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4, int a5)
{
  int v5; // ebx@1
  int v6; // esi@1
  signed int result; // eax@1
  int v8; // edi@1

  v5 = a1;
  v6 = a2;
  result = 0;
  v8 = 0;
  if ( !a2 )
    goto LABEL_11;
  do
  {
    if ( !a5 )
      break;
    if ( !*(_WORD *)v5 )
      break;
    *(_WORD *)a3 = *(_WORD *)v5;
    a3 += 2;
    v5 += 2;
    --v6;
    --a5;
    ++v8;
  }
  while ( v6 );
  if ( !v6 )
  {
LABEL_11:
    a3 -= 2;
    --v8;
    result = -2147483643;
  }
  *(_WORD *)a3 = 0;
  if ( a4 )
    *(_DWORD *)a4 = v8;
  return result;
}

//----- (0001105E) --------------------------------------------------------
NTSTATUS __stdcall RtlStringCbCopyW(wchar_t *pszDest, size_t cbDest, const wchar_t *pszSrc)
{
  int v3; // edx@1
  NTSTATUS result; // eax@1

  v3 = cbDest >> 1;
  result = 0;
  if ( !(cbDest >> 1) || (unsigned int)v3 > 0x7FFFFFFF )
    result = -1073741811;
  if ( result >= 0 )
    result = RtlStringCbCallback((int)pszSrc, v3, (int)pszDest, 0, 2147483646);
  return result;
}

//----- (0001109A) --------------------------------------------------------
NTSTATUS __stdcall RtlStringCbCatW(wchar_t *pszDest, size_t cbDest, const wchar_t *pszSrc)
{
  size_t v3; // edx@1
  NTSTATUS result; // eax@1
  int v5; // ecx@5
  size_t v6; // esi@5
  wchar_t *v7; // eax@5
  NTSTATUS cbDesta; // [sp+14h] [bp+Ch]@5

  v3 = cbDest >> 1;
  result = 0;
  if ( !(cbDest >> 1) || v3 > 0x7FFFFFFF )
    result = -1073741811;
  if ( result < 0 )
  {
    v5 = 0;
  }
  else
  {
    cbDesta = 0;
    v5 = 0;
    v6 = v3;
    v7 = pszDest;
    if ( !v3 )
      goto LABEL_17;
    do
    {
      if ( !*v7 )
        break;
      ++v7;
      --v6;
    }
    while ( v6 );
    if ( v6 )
      v5 = v3 - v6;
    else
LABEL_17:
      cbDesta = -1073741811;
    result = cbDesta;
  }
  if ( result >= 0 )
    result = RtlStringCbCallback((int)pszSrc, v3 - v5, (int)&pszDest[v5], 0, 0x7FFFFFFF);
  return result;
}

//----- (00011112) --------------------------------------------------------
NTSTATUS __stdcall UnHandledDispatch(int a1, PIRP Irp)
{
  int v2; // eax@1
  NTSTATUS v3; // esi@1
  PIRP v4; // edx@2

  v2 = *(_DWORD *)(a1 + 40);
  v3 = -1073741637;
  if ( *(_DWORD *)v2 == 542065734 )
  {
    v4 = Irp;
    ++v4->CurrentLocation;
    v4->Tail.Overlay.PacketType += 36;
    v3 = IofCallDriver(*(PDEVICE_OBJECT *)(v2 + 12), Irp);
  }
  else
  {
    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = -1073741637;
    IofCompleteRequest(Irp, 0);
  }
  return v3;
}

//----- (00011162) --------------------------------------------------------
NTSTATUS __stdcall ForwardIrp(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
  PIRP v2; // edx@1

  v2 = Irp;
  ++v2->CurrentLocation;
  v2->Tail.Overlay.PacketType += 36;
  return IofCallDriver(DeviceObject, Irp);
}

//----- (00011184) --------------------------------------------------------
NTSTATUS RtlStringCbPrintfA(char *pszDest, size_t cbDest, const char *pszFormat, ...)
{
  NTSTATUS result; // eax@1
  size_t v4; // esi@5
  NTSTATUS v5; // ebx@5
  int v6; // eax@5
  va_list va; // [sp+14h] [bp+14h]@1

  va_start(va, pszFormat);
  result = 0;
  if ( !cbDest || cbDest > 0x7FFFFFFF )
    result = -1073741811;
  if ( result >= 0 )
  {
    v4 = cbDest - 1;
    v5 = 0;
    v6 = __vsnprintf(pszDest, cbDest - 1, pszFormat, va);
    if ( v6 < 0 || v6 > v4 )
    {
      pszDest[v4] = 0;
      v5 = -2147483643;
    }
    else if ( v6 == v4 )
    {
      pszDest[v4] = 0;
    }
    result = v5;
  }
  return result;
}

//----- (000111E4) --------------------------------------------------------
signed int __stdcall CreateEnumObject(int a1, int a2, char a3)
{
  PVOID v3; // eax@1
  int v4; // esi@1
  HANDLE *v6; // edi@5
  PKEVENT v7; // eax@5
  UNICODE_STRING DestinationString; // [sp+Ch] [bp-Ch]@5
  HANDLE ThreadHandle; // [sp+14h] [bp-4h]@7
  NTSTATUS v10; // [sp+28h] [bp+10h]@6

  *(_DWORD *)a2 = 0;
  v3 = ExAllocatePoolWithTag(0, 0xBF0u, DebugMemoryTag);
  v4 = (int)v3;
  if ( !v3 )
    return -1073741801;
  memset(v3, 0, 0xBF0u);
  KeInitializeEvent((PRKEVENT)(v4 + 4), 0, 0);
  KeInitializeTimerEx((PKTIMER)(v4 + 24), SynchronizationTimer);
  KeInitializeEvent((PRKEVENT)(v4 + 64), SynchronizationEvent, 1u);
  *(_DWORD *)(v4 + 100) = a1;
  if ( a3 )
    CreateStaticDevice(v4);
  RtlInitUnicodeString(&DestinationString, L"\\Device\\IrEnumIoEvent");
  v6 = (HANDLE *)(v4 + 80);
  v7 = IoCreateNotificationEvent(&DestinationString, (PHANDLE)(v4 + 80));
  *(_DWORD *)(v4 + 84) = v7;
  if ( !v7 )
  {
    v10 = -1073741801;
LABEL_9:
    KeSetEvent((PRKEVENT)(v4 + 4), 0, 0);
    if ( *(_DWORD *)v4 )
    {
      KeWaitForSingleObject(*(PVOID *)v4, 0, 0, 0, 0);
      ObfDereferenceObject(*(PVOID *)v4);
    }
    if ( *v6 )
      ZwClose(*v6);
    ExFreePoolWithTag((PVOID)v4, 0);
    return v10;
  }
  v10 = PsCreateSystemThread(&ThreadHandle, 0x1FFFFFu, 0, 0, 0, WorkerThread, (PVOID)v4);
  if ( v10 < 0 )
    goto LABEL_9;
  v10 = ObReferenceObjectByHandle(ThreadHandle, 0, 0, 0, (PVOID *)v4, 0);
  ZwClose(ThreadHandle);
  ThreadHandle = 0;
  if ( v10 < 0 )
    goto LABEL_9;
  *(_DWORD *)a2 = v4;
  return v10;
}

//----- (0001137C) --------------------------------------------------------
NTSTATUS __stdcall IrdaOpenControlChannel(PHANDLE FileHandle)
{
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+0h] [bp-28h]@1
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+18h] [bp-10h]@1
  UNICODE_STRING DestinationString; // [sp+20h] [bp-8h]@1

  RtlInitUnicodeString(&DestinationString, L"\\Device\\IrDA");
  ObjectAttributes.RootDirectory = 0;
  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  ObjectAttributes.Length = 24;
  ObjectAttributes.Attributes = 576;
  ObjectAttributes.ObjectName = &DestinationString;
  return ZwCreateFile(FileHandle, 0xC0100000, &ObjectAttributes, &IoStatusBlock, 0, 0, 3u, 2u, 0, 0, 0);
}

//----- (000113DA) --------------------------------------------------------
NTSTATUS __stdcall IrdaLazyDiscoverDevices(HANDLE FileHandle, HANDLE Event, PIO_STATUS_BLOCK IoStatusBlock, PVOID OutputBuffer, ULONG OutputBufferLength)
{
  return ZwDeviceIoControlFile(
           FileHandle,
           Event,
           0,
           0,
           IoStatusBlock,
           0x120018u,
           0,
           0,
           OutputBuffer,
           OutputBufferLength);
}

//----- (00011408) --------------------------------------------------------
HRESULT __stdcall StringCbCopyA(STRSAFE_LPSTR pszDest, size_t cbDest, STRSAFE_LPCSTR pszSrc)
{
  HRESULT result; // eax@1
  STRSAFE_LPSTR v4; // eax@5
  HRESULT v5; // ebx@5
  size_t v6; // esi@5
  char v7; // cl@7

  result = 0;
  if ( !cbDest || cbDest > 0x7FFFFFFF )
    result = -2147024809;
  if ( result >= 0 )
  {
    v4 = pszDest;
    v5 = 0;
    v6 = cbDest;
    if ( !cbDest )
      goto LABEL_14;
    do
    {
      if ( !(2147483646 - cbDest + v6) )
        break;
      v7 = v4[pszSrc - pszDest];
      if ( !v7 )
        break;
      *v4++ = v7;
      --v6;
    }
    while ( v6 );
    if ( !v6 )
    {
LABEL_14:
      --v4;
      v5 = -2147024774;
    }
    *v4 = 0;
    result = v5;
  }
  return result;
}

//----- (00011470) --------------------------------------------------------
NTSTATUS __stdcall IrdaIASStringQuery(int a1, STRSAFE_LPCSTR pszSrc, STRSAFE_LPCSTR a3, int a4)
{
  NTSTATUS result; // eax@2
  NTSTATUS v5; // esi@5
  size_t v6; // eax@9
  WCHAR *v7; // eax@11
  NTSTATUS v8; // eax@14
  STRING DestinationString; // [sp+8h] [bp-770h]@15
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+10h] [bp-768h]@5
  HANDLE FileHandle; // [sp+18h] [bp-760h]@4
  UNICODE_STRING Destination; // [sp+1Ch] [bp-75Ch]@8
  int InputBuffer; // [sp+24h] [bp-754h]@1
  char pszDest; // [sp+28h] [bp-750h]@3
  char v15; // [sp+68h] [bp-710h]@4
  size_t v16; // [sp+16Ch] [bp-60Ch]@9
  int v17; // [sp+170h] [bp-608h]@8
  char v18; // [sp+174h] [bp-604h]@13
  WCHAR Source; // [sp+570h] [bp-208h]@13

  InputBuffer = a1;
  *(_DWORD *)a4 = 0;
  if ( strlen(pszSrc) + 1 > 0x40 )
    return -1073741811;
  StringCbCopyA(&pszDest, 0x40u, pszSrc);
  if ( strlen(a3) + 1 > 0x100 )
    return -1073741811;
  StringCbCopyA(&v15, 0x100u, a3);
  result = IrdaOpenControlChannel(&FileHandle);
  if ( result >= 0 )
  {
    v5 = ZwDeviceIoControlFile(
           FileHandle,
           0,
           0,
           0,
           &IoStatusBlock,
           0x12000Cu,
           &InputBuffer,
           0x54Cu,
           &InputBuffer,
           0x54Cu);
    if ( v5 == 259 )
    {
      ZwWaitForSingleObject(FileHandle, 1u, 0);
      v5 = IoStatusBlock.Status;
    }
    ZwClose(FileHandle);
    if ( v5 >= 0 )
    {
      Destination.Length = 0;
      if ( v17 == 255 )
        LOWORD(v6) = v16 + 1;
      else
        v6 = 2 * v16 + 2;
      Destination.MaximumLength = v6;
      v7 = (WCHAR *)ExAllocatePoolWithTag(PagedPool, (unsigned __int16)v6, DebugMemoryTag);
      Destination.Buffer = v7;
      if ( !v7 )
        return -1073741670;
      memset(v7, 0, Destination.MaximumLength);
      memset(&Source, 0, 0x202u);
      memcpy(&Source, &v18, v16);
      if ( v17 == 255 )
      {
        v8 = RtlAppendUnicodeToString(&Destination, &Source);
      }
      else
      {
        RtlInitAnsiString(&DestinationString, (PCSZ)&Source);
        v8 = RtlAnsiStringToUnicodeString(&Destination, &DestinationString, 0);
      }
      v5 = v8;
      if ( v8 < 0 )
        ExFreePoolWithTag(Destination.Buffer, 0);
      else
        *(_DWORD *)a4 = Destination.Buffer;
    }
    result = v5;
  }
  return result;
}

//----- (00011668) --------------------------------------------------------
NTSTATUS __stdcall IrdaIASIntegerQuery(int a1, STRSAFE_LPCSTR pszSrc, STRSAFE_LPCSTR a3, int a4)
{
  NTSTATUS result; // eax@2
  NTSTATUS v5; // esi@5
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+8h] [bp-55Ch]@5
  HANDLE FileHandle; // [sp+10h] [bp-554h]@4
  int InputBuffer; // [sp+14h] [bp-550h]@1
  char pszDest; // [sp+18h] [bp-54Ch]@3
  char v10; // [sp+58h] [bp-50Ch]@4
  int v11; // [sp+158h] [bp-40Ch]@9
  int v12; // [sp+15Ch] [bp-408h]@11

  InputBuffer = a1;
  *(_DWORD *)a4 = 0;
  if ( strlen(pszSrc) + 1 > 0x40 || (StringCbCopyA(&pszDest, 0x40u, pszSrc), strlen(a3) + 1 > 0x100) )
  {
    result = -1073741811;
  }
  else
  {
    StringCbCopyA(&v10, 0x100u, a3);
    result = IrdaOpenControlChannel(&FileHandle);
    if ( result >= 0 )
    {
      v5 = ZwDeviceIoControlFile(
             FileHandle,
             0,
             0,
             0,
             &IoStatusBlock,
             0x12000Cu,
             &InputBuffer,
             0x54Cu,
             &InputBuffer,
             0x54Cu);
      if ( v5 == 259 )
      {
        ZwWaitForSingleObject(FileHandle, 1u, 0);
        v5 = IoStatusBlock.Status;
      }
      ZwClose(FileHandle);
      if ( v5 >= 0 )
      {
        if ( v11 == 1 )
        {
          *(_DWORD *)a4 = v12;
          result = 0;
        }
        else
        {
          result = -1073741823;
        }
      }
      else
      {
        result = v5;
      }
    }
  }
  return result;
}

//----- (00014006) --------------------------------------------------------
NTSTATUS __stdcall IrEnumPdoWmi(int a1, PIRP Irp)
{
  NTSTATUS v2; // esi@1

  v2 = Irp->IoStatus.Status;
  IofCompleteRequest(Irp, 0);
  return v2;
}

//----- (00014026) --------------------------------------------------------
NTSTATUS __stdcall IrEnumPdoPower(int a1, PIRP Irp)
{
  NTSTATUS v2; // ebx@1
  struct _IRP::$::$::$::$A02EC6A2CE86544F716F4825015773AC::_IO_STACK_LOCATION *v3; // edi@1

  v2 = Irp->IoStatus.Status;
  v3 = Irp->Tail.Overlay.CurrentStackLocation;
  PoStartNextPowerIrp(Irp);
  if ( (unsigned __int8)(*((_BYTE *)v3 + 1) - 2) <= 1u )
    v2 = 0;
  Irp->IoStatus.Status = v2;
  IofCompleteRequest(Irp, 0);
  return v2;
}

//----- (00014064) --------------------------------------------------------
int __stdcall IrEnumPdoPnp(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
  signed int v2; // ebx@1
  PVOID v3; // esi@1
  struct _IRP::$::$::$::$A02EC6A2CE86544F716F4825015773AC::_IO_STACK_LOCATION *v4; // edi@1
  signed int v5; // eax@1
  int v6; // eax@4
  int v7; // eax@5
  int v8; // eax@6
  int v9; // eax@7
  int v10; // eax@8
  bool v11; // zf@9
  PVOID v12; // esi@17
  PDEVICE_OBJECT v13; // edi@18
  PIRP v14; // eax@18
  int v15; // eax@19
  int v16; // eax@20
  int v17; // eax@21
  int v18; // eax@22
  int v19; // eax@23
  void *v20; // eax@25
  signed int v21; // eax@29
  int v22; // eax@33
  __int16 v23; // cx@34
  int v24; // eax@35
  size_t v25; // ebx@35
  int v26; // edi@35
  struct _DEVICE_OBJECT *v27; // eax@35
  int v28; // eax@38
  int v29; // edi@38
  int v30; // ecx@39
  int v31; // eax@40
  int v32; // edx@40
  __int16 v33; // bx@41
  int v34; // edi@43
  struct _DEVICE_OBJECT *v35; // eax@43
  int v36; // ebx@44
  int v37; // eax@44
  char *v38; // eax@48
  int v39; // ecx@48
  __int16 v40; // dx@49
  int v41; // eax@50
  int v42; // ecx@50
  int v43; // eax@54
  int v44; // edx@54
  __int16 v45; // cx@55
  int v46; // ebx@56
  struct _DEVICE_OBJECT *v47; // eax@56
  PIRP v48; // eax@62
  PDEVICE_OBJECT v49; // ecx@64
  int v50; // esi@65
  int v51; // edi@65
  bool v52; // dl@65
  int v53; // eax@68
  int v54; // edx@69
  __int16 v55; // cx@70
  int v56; // eax@71
  size_t v57; // edi@72
  struct _DEVICE_OBJECT *v58; // eax@72
  struct _DEVICE_OBJECT *v59; // eax@74
  int v60; // eax@81
  unsigned int v61; // ecx@81
  struct _IRP *v62; // ecx@84
  UNICODE_STRING DestinationString; // [sp+Ch] [bp-Ch]@15
  int v65; // [sp+14h] [bp-4h]@45

  v2 = Irp->IoStatus.Status;
  v3 = DeviceObject->DeviceExtension;
  v4 = Irp->Tail.Overlay.CurrentStackLocation;
  v5 = *((_BYTE *)v4 + 1);
  if ( v5 <= 7 )
  {
    if ( v5 != 7 )
    {
      if ( !*((_BYTE *)v4 + 1) )
      {
        if ( *(_BYTE *)(*((_DWORD *)v3 + 2) + 143) )
        {
          v2 = IoOpenDeviceRegistryKey(DeviceObject, 1u, 0x20000u, (PHANDLE)&DeviceObject);
          if ( v2 >= 0 )
          {
            RtlInitUnicodeString(&DestinationString, L"PortName");
            v2 = ZwSetValueKey(DeviceObject, &DestinationString, 0, 1u, L"IR", 6u);
            ZwClose(DeviceObject);
          }
        }
        goto LABEL_84;
      }
      v6 = v5 - 1;
      if ( !v6 )
      {
LABEL_11:
        v2 = 0;
        goto LABEL_84;
      }
      v7 = v6 - 1;
      if ( !v7 )
      {
        RemoveDevice(*(_DWORD *)(*(_DWORD *)(*((_DWORD *)v3 + 1) + 40) + 16), *((void **)v3 + 2));
        goto LABEL_11;
      }
      v8 = v7 - 1;
      if ( !v8 )
        goto LABEL_11;
      v9 = v8 - 1;
      if ( !v9 )
        goto LABEL_11;
      v10 = v9 - 1;
      if ( !v10 )
        goto LABEL_11;
      v11 = v10 == 1;
      goto LABEL_10;
    }
    if ( *((_DWORD *)v4 + 1) != 4 )
      goto LABEL_84;
    v12 = ExAllocatePoolWithTag(PagedPool, 8u, DebugMemoryTag);
    if ( v12 )
    {
      v13 = DeviceObject;
      ObfReferenceObject(DeviceObject);
      v14 = Irp;
      *((_DWORD *)v12 + 1) = v13;
      *(_DWORD *)v12 = 1;
      v14->IoStatus.Information = (ULONG_PTR)v12;
      goto LABEL_11;
    }
LABEL_28:
    v2 = -1073741670;
    goto LABEL_84;
  }
  v15 = v5 - 9;
  if ( !v15 )
  {
    v60 = *((_DWORD *)v4 + 1);
    *(_WORD *)(v60 + 2) = 1;
    *(_WORD *)v60 = 64;
    v2 = 0;
    v61 = *(_DWORD *)(v60 + 4) & 0xFFFFFFF3 | 0x200;
    *(_DWORD *)(v60 + 44) = 0;
    *(_DWORD *)(v60 + 48) = 0;
    *(_DWORD *)(v60 + 52) = 0;
    *(_DWORD *)(v60 + 56) = 0;
    *(_DWORD *)(v60 + 60) = 0;
    *(_DWORD *)(v60 + 4) = v61;
    if ( *(_BYTE *)(*((_DWORD *)v3 + 2) + 143) )
      *(_DWORD *)(v60 + 4) = v61 | 0x100;
    *(_DWORD *)(v60 + 4) &= 0xFFFFFFDF;
    goto LABEL_84;
  }
  v16 = v15 - 3;
  if ( !v16 )
  {
    if ( *((_DWORD *)v4 + 1) )
      goto LABEL_84;
    v53 = *(_DWORD *)(*((_DWORD *)v3 + 2) + 132);
    if ( !v53 )
      goto LABEL_87;
    v54 = v53 + 2;
    do
    {
      v55 = *(_WORD *)v53;
      v53 += 2;
    }
    while ( v55 );
    v56 = 2 * ((v53 - v54) >> 1);
    if ( v56 )
    {
      v57 = v56 + 2;
      v58 = (struct _DEVICE_OBJECT *)ExAllocatePoolWithTag(PagedPool, v56 + 2, DebugMemoryTag);
      DeviceObject = v58;
      if ( v58 )
      {
        v58->Type = 0;
        RtlStringCbCopyW((wchar_t *)v58, v57, *(const wchar_t **)(*((_DWORD *)v3 + 2) + 132));
        goto LABEL_76;
      }
    }
    else
    {
LABEL_87:
      v59 = (struct _DEVICE_OBJECT *)ExAllocatePoolWithTag(PagedPool, 0x30u, DebugMemoryTag);
      DeviceObject = v59;
      if ( v59 )
      {
        qmemcpy(v59, L"IR Communication Device", 0x30u);
        goto LABEL_76;
      }
    }
    v2 = -1073741670;
    goto LABEL_78;
  }
  v17 = v16 - 3;
  if ( !v17 )
  {
    if ( *((_DWORD *)v4 + 1) )
      goto LABEL_84;
    v49 = (PDEVICE_OBJECT)8;
    if ( *((_DWORD *)v4 + 4) < 8u )
    {
      v2 = -1073741789;
      goto LABEL_84;
    }
    v50 = *((_DWORD *)v3 + 2);
    v51 = *((_DWORD *)v4 + 2);
    v52 = *(_BYTE *)(v50 + 142) == 0;
    *(_DWORD *)v51 = *(_DWORD *)v50;
    LOBYTE(DestinationString.Buffer) = v52;
    *(_DWORD *)(v51 + 4) = DestinationString.Buffer;
    v48 = Irp;
    v2 = 0;
LABEL_80:
    v48->IoStatus.Information = (ULONG_PTR)v49;
    goto LABEL_84;
  }
  v18 = v17 - 4;
  if ( !v18 )
  {
    v21 = *((_DWORD *)v4 + 1);
    if ( v21 < 0 )
      goto LABEL_84;
    if ( v21 <= 1 )
    {
      v43 = *(_DWORD *)(*((_DWORD *)v3 + 2) + 56);
      v44 = v43 + 2;
      do
      {
        v45 = *(_WORD *)v43;
        v43 += 2;
      }
      while ( v45 );
      v46 = 2 * ((v43 - v44) >> 1) + 20;
      v47 = (struct _DEVICE_OBJECT *)ExAllocatePoolWithTag(PagedPool, v46, DebugMemoryTag);
      DeviceObject = v47;
      if ( v47 )
      {
        memset(v47, 0, v46);
        if ( !*((_DWORD *)v4 + 1) || !*(_BYTE *)(*((_DWORD *)v3 + 2) + 143) )
          RtlStringCbCopyW((wchar_t *)DeviceObject, v46, L"IRENUM\\");
        RtlStringCbCatW((wchar_t *)DeviceObject, v46, *(const wchar_t **)(*((_DWORD *)v3 + 2) + 56));
        v2 = 0;
      }
      else
      {
        v2 = -1073741801;
      }
      v48 = Irp;
      goto LABEL_79;
    }
    if ( v21 == 2 )
    {
      v28 = *((_DWORD *)v3 + 2);
      v29 = 0;
      if ( *(_DWORD *)(v28 + 60) > 0 )
      {
        v30 = v28 + 64;
        DeviceObject = *(PDEVICE_OBJECT *)(v28 + 60);
        do
        {
          v31 = *(_DWORD *)v30;
          v32 = *(_DWORD *)v30 + 2;
          do
          {
            v33 = *(_WORD *)v31;
            v31 += 2;
          }
          while ( v33 );
          v30 += 4;
          v11 = DeviceObject == (PDEVICE_OBJECT)1;
          DeviceObject = (PDEVICE_OBJECT)((char *)DeviceObject - 1);
          v29 += 2 * ((v31 - v32) >> 1) + 18;
        }
        while ( !v11 );
      }
      v34 = v29 + 4;
      v35 = (struct _DEVICE_OBJECT *)ExAllocatePoolWithTag(PagedPool, v34, DebugMemoryTag);
      DeviceObject = v35;
      if ( v35 )
      {
        v36 = 0;
        memset(v35, 0, v34);
        v37 = *((_DWORD *)v3 + 2);
        DestinationString.Buffer = 0;
        if ( *(_DWORD *)(v37 + 60) > 0 )
        {
          v65 = 64;
          do
          {
            if ( !*(_BYTE *)(v37 + 143) )
              RtlStringCbCopyW((wchar_t *)DeviceObject + v36, v34, L"IRENUM\\");
            RtlStringCbCatW((wchar_t *)DeviceObject + v36, v34, *(const wchar_t **)(*((_DWORD *)v3 + 2) + v65));
            v38 = (char *)DeviceObject + 2 * v36;
            v39 = (int)(v38 + 2);
            do
            {
              v40 = *(_WORD *)v38;
              v38 += 2;
            }
            while ( v40 );
            v65 += 4;
            v41 = ((signed int)&v38[-v39] >> 1) + 1;
            v42 = -v41;
            v36 += v41;
            ++DestinationString.Buffer;
            v37 = *((_DWORD *)v3 + 2);
            v34 += 2 * v42;
          }
          while ( (signed int)DestinationString.Buffer < *(_DWORD *)(v37 + 60) );
        }
        v2 = 0;
      }
      else
      {
        v2 = -1073741670;
      }
      v20 = DeviceObject;
      goto LABEL_27;
    }
    if ( v21 != 3 )
      goto LABEL_84;
    v22 = *((_DWORD *)v3 + 2) + 4;
    do
    {
      v23 = *(_WORD *)v22;
      v22 += 2;
    }
    while ( v23 );
    v24 = (v22 - (*((_DWORD *)v3 + 2) + 6)) >> 1;
    v25 = 2 * v24;
    v26 = 2 * v24 + 2;
    v27 = (struct _DEVICE_OBJECT *)ExAllocatePoolWithTag(PagedPool, v26, DebugMemoryTag);
    DeviceObject = v27;
    if ( !v27 )
    {
      v2 = -1073741801;
LABEL_78:
      v48 = Irp;
      Irp->IoStatus.Status = v2;
LABEL_79:
      v49 = DeviceObject;
      goto LABEL_80;
    }
    memset(v27, 0, v26);
    memcpy(DeviceObject, (const void *)(*((_DWORD *)v3 + 2) + 4), v25);
LABEL_76:
    v2 = 0;
    goto LABEL_78;
  }
  v19 = v18 - 2;
  if ( !v19 )
  {
    v20 = ExAllocatePoolWithTag(PagedPool, 0x18u, DebugMemoryTag);
    if ( !v20 )
      goto LABEL_28;
    *(_DWORD *)v20 = GUID_BUS_TYPE_IRDA.Data1;
    *((_DWORD *)v20 + 1) = *(_DWORD *)&GUID_BUS_TYPE_IRDA.Data2;
    *((_DWORD *)v20 + 2) = *(_DWORD *)&GUID_BUS_TYPE_IRDA.Data4[0];
    *((_DWORD *)v20 + 3) = *(_DWORD *)&GUID_BUS_TYPE_IRDA.Data4[4];
    v2 = 0;
    *((_DWORD *)v20 + 4) = 15;
    *((_DWORD *)v20 + 5) = 0;
LABEL_27:
    Irp->IoStatus.Information = (ULONG_PTR)v20;
    goto LABEL_84;
  }
  v11 = v19 == 2;
LABEL_10:
  if ( v11 )
    goto LABEL_11;
LABEL_84:
  v62 = Irp;
  Irp->IoStatus.Status = v2;
  IofCompleteRequest(v62, 0);
  return v2;
}
// 15258: using guessed type wchar_t aIrCommunicatio[24];
// 15298: using guessed type wchar_t aIr[3];

//----- (000144EE) --------------------------------------------------------
void __stdcall IrEnumUnload(int a1)
{
  ExFreePoolWithTag(Path, 0);
  Path = 0;
}

//----- (0001450C) --------------------------------------------------------
int __stdcall IrEnumAddDevice(PDRIVER_OBJECT DriverObject, PDEVICE_OBJECT TargetDevice)
{
  signed int v2; // edi@1
  PDEVICE_OBJECT v3; // eax@2
  struct _DEVICE_OBJECT *v4; // esi@2
  PVOID v5; // eax@4
  bool v6; // cl@4
  PDEVICE_OBJECT DeviceObject; // [sp+Ch] [bp-4h]@1

  DeviceObject = 0;
  v2 = IoCreateDevice(DriverObject, 0x18u, 0, 0x15u, 0x80u, 0, &DeviceObject);
  if ( v2 >= 0 )
  {
    v3 = IoAttachDeviceToDeviceStack(DeviceObject, TargetDevice);
    v4 = v3;
    if ( v3 )
    {
      DeviceObject->Flags |= v3->Flags;
      DeviceObject->Flags &= 0xFFFFFF7F;
      DeviceObject->StackSize = v3->StackSize + 1;
      v5 = DeviceObject->DeviceExtension;
      *(_DWORD *)v5 = 542065734;
      *((_DWORD *)v5 + 1) = DeviceObject;
      *((_DWORD *)v5 + 2) = TargetDevice;
      *((_DWORD *)v5 + 3) = v4;
      v6 = EnumStaticDevice != 0;
      *((_BYTE *)v5 + 20) = EnumStaticDevice != 0;
      v2 = CreateEnumObject((int)DeviceObject, (int)((char *)v5 + 16), v6);
      if ( v2 >= 0 )
        return 0;
    }
    else
    {
      v2 = -1073741670;
    }
    if ( v4 )
      IoDetachDevice(v4);
  }
  if ( DeviceObject )
    IoDeleteDevice(DeviceObject);
  return v2;
}
// 13010: using guessed type int EnumStaticDevice;

//----- (000145D2) --------------------------------------------------------
int __stdcall IrEnumPnP(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
  PVOID v2; // ebx@1
  int v3; // ecx@1
  struct _IRP::$::$::$::$A02EC6A2CE86544F716F4825015773AC::_IO_STACK_LOCATION *v4; // eax@1
  signed int v6; // ecx@5
  int v7; // ecx@8
  int v8; // ecx@9
  struct _IRP::$::$::$::$A02EC6A2CE86544F716F4825015773AC::_IO_STACK_LOCATION *v9; // esi@13
  NTSTATUS v10; // esi@13
  void *v11; // ebx@13
  int v12; // ecx@16
  int v13; // ecx@17
  int v14; // ecx@18
  int v15; // eax@22
  signed int v16; // edi@23

  v2 = DeviceObject->DeviceExtension;
  v3 = *(_DWORD *)v2;
  v4 = Irp->Tail.Overlay.CurrentStackLocation;
  if ( *(_DWORD *)v2 == 542065744 || v3 == 1329877112 )
    return IrEnumPdoPnp(DeviceObject, Irp);
  if ( v3 != 542065734 )
  {
    DbgPrint("IRENUM: IrEnumPnp: Bad DevObj\n");
    Irp->IoStatus.Status = 0;
    IofCompleteRequest(Irp, 0);
    return 0;
  }
  v6 = *((_BYTE *)v4 + 1);
  if ( v6 > 4 )
  {
    v12 = v6 - 5;
    if ( v12 )
    {
      v13 = v12 - 1;
      if ( v13 )
      {
        v14 = v13 - 1;
        if ( !v14 )
        {
          if ( *((_DWORD *)v4 + 1) )
            return ForwardIrp(*((PDEVICE_OBJECT *)v2 + 3), Irp);
          v15 = *((_DWORD *)v2 + 4);
          if ( !v15 )
            return ForwardIrp(*((PDEVICE_OBJECT *)v2 + 3), Irp);
          v16 = GetDeviceList(v15, (int)Irp);
          Irp->IoStatus.Status = v16;
          if ( v16 >= 0 )
            return ForwardIrp(*((PDEVICE_OBJECT *)v2 + 3), Irp);
          IofCompleteRequest(Irp, 0);
          return v16;
        }
        if ( v14 != 16 )
          return ForwardIrp(*((PDEVICE_OBJECT *)v2 + 3), Irp);
      }
    }
LABEL_20:
    Irp->IoStatus.Status = 0;
    return ForwardIrp(*((PDEVICE_OBJECT *)v2 + 3), Irp);
  }
  if ( v6 == 4 )
    goto LABEL_20;
  if ( !*((_BYTE *)v4 + 1) )
    goto LABEL_11;
  v7 = v6 - 1;
  if ( !v7 )
    goto LABEL_11;
  v8 = v7 - 1;
  if ( v8 )
  {
    if ( v8 != 1 )
      return ForwardIrp(*((PDEVICE_OBJECT *)v2 + 3), Irp);
LABEL_11:
    Irp->IoStatus.Status = 0;
    return ForwardIrp(*((PDEVICE_OBJECT *)v2 + 3), Irp);
  }
  *((_BYTE *)v2 + 21) = 1;
  *((_BYTE *)v2 + 22) = 1;
  v9 = Irp->Tail.Overlay.CurrentStackLocation;
  qmemcpy((char *)v9 - 36, (const void *)v9, 0x1Cu);
  *((_BYTE *)v9 - 33) = 0;
  v10 = IofCallDriver(*((PDEVICE_OBJECT *)v2 + 3), Irp);
  IoDetachDevice(*((PDEVICE_OBJECT *)v2 + 3));
  *(_DWORD *)v2 = 1329874552;
  v11 = (void *)*((_DWORD *)v2 + 4);
  if ( v11 )
    CloseEnumObject(v11);
  IoDeleteDevice(DeviceObject);
  return v10;
}

//----- (00014704) --------------------------------------------------------
NTSTATUS __stdcall IrEnumPower(int a1, PIRP Irp)
{
  int v2; // edi@1
  PIRP v3; // esi@3
  NTSTATUS result; // eax@3

  v2 = *(_DWORD *)(a1 + 40);
  if ( *(_DWORD *)v2 == 542065744 || *(_DWORD *)v2 == 1329877112 )
  {
    result = IrEnumPdoPower(a1, Irp);
  }
  else
  {
    v3 = Irp;
    PoStartNextPowerIrp(Irp);
    ++v3->CurrentLocation;
    v3->Tail.Overlay.PacketType += 36;
    result = PoCallDriver(*(PDEVICE_OBJECT *)(v2 + 12), Irp);
  }
  return result;
}

//----- (00014752) --------------------------------------------------------
NTSTATUS __stdcall IrEnumWmi(int a1, PIRP Irp)
{
  int v2; // eax@1
  NTSTATUS v3; // esi@4
  NTSTATUS result; // eax@6

  v2 = *(_DWORD *)(a1 + 40);
  if ( *(_DWORD *)v2 == 542065744 || *(_DWORD *)v2 == 1329877112 )
  {
    result = IrEnumPdoWmi(a1, Irp);
  }
  else
  {
    if ( *(_DWORD *)(Irp->Tail.Overlay.PacketType + 4) == a1 )
    {
      v3 = Irp->IoStatus.Status;
      IofCompleteRequest(Irp, 0);
    }
    else
    {
      v3 = ForwardIrp(*(PDEVICE_OBJECT *)(v2 + 12), Irp);
    }
    result = v3;
  }
  return result;
}

//----- (000147AA) --------------------------------------------------------
NTSTATUS __stdcall DeviceNameFromDeviceInfo(int a1, WCHAR *a2, int a3)
{
  bool v3; // zf@1
  NTSTATUS result; // eax@2
  STRING DestinationString; // [sp+Ch] [bp-44h]@3
  UNICODE_STRING Destination; // [sp+14h] [bp-3Ch]@1
  WCHAR Source; // [sp+1Ch] [bp-34h]@1

  Destination.Buffer = a2;
  memset(&Source, 0, 0x2Eu);
  qmemcpy(&Source, (const void *)(a1 + 4), 0x16u);
  memset(a2, 0, 2 * a3);
  v3 = *(_BYTE *)(a1 + 28) == -1;
  Destination.Length = 0;
  Destination.Buffer = a2;
  Destination.MaximumLength = 2 * a3 - 2;
  if ( v3 )
  {
    result = RtlAppendUnicodeToString(&Destination, &Source);
  }
  else
  {
    RtlInitAnsiString(&DestinationString, (PCSZ)&Source);
    result = RtlAnsiStringToUnicodeString(&Destination, &DestinationString, 0);
  }
  return result;
}

//----- (0001484E) --------------------------------------------------------
NTSTATUS __stdcall CreatePdo(PDEVICE_OBJECT DeviceObject, int a2)
{
  PDEVICE_OBJECT v2; // esi@1
  NTSTATUS result; // eax@1
  PVOID v4; // ecx@2
  int v5; // edx@2
  PDEVICE_OBJECT v6; // ecx@2

  v2 = DeviceObject;
  result = IoCreateDevice(DeviceObject->DriverObject, 0xCu, 0, 0x2Au, 0x80u, 0, &DeviceObject);
  if ( result >= 0 )
  {
    v4 = DeviceObject->DeviceExtension;
    v5 = a2;
    *(_DWORD *)v4 = 542065744;
    *((_DWORD *)v4 + 1) = v2;
    *((_DWORD *)v4 + 2) = v5;
    v6 = DeviceObject;
    *(_DWORD *)(v5 + 148) = DeviceObject;
    v6->Flags |= 0x2000u;
    DeviceObject->Flags &= 0xFFFFFF7F;
  }
  return result;
}

//----- (000148AE) --------------------------------------------------------
int __stdcall FixupDeviceId(int a1)
{
  int result; // eax@1
  unsigned __int16 v2; // cx@2

  for ( result = a1; *(_WORD *)result; result += 2 )
  {
    v2 = *(_WORD *)result;
    if ( *(_WORD *)result < 0x20u || v2 > 0x7Fu || v2 == 44 )
      *(_WORD *)result = 63;
  }
  return result;
}

//----- (000148E4) --------------------------------------------------------
signed int __stdcall GetDeviceList(int a1, int a2)
{
  int v2; // ebx@1
  unsigned int v3; // esi@1
  void *v4; // edi@1
  PVOID v5; // esi@4
  int v6; // eax@7
  int v7; // edi@10
  signed int v8; // ebx@10
  int v9; // eax@11
  struct _KEVENT *Event; // [sp+Ch] [bp-8h]@1
  signed int v12; // [sp+10h] [bp-4h]@1
  unsigned int v13; // [sp+1Ch] [bp+8h]@6

  v2 = a1;
  v3 = *(_DWORD *)(a1 + 104);
  v4 = *(void **)(a2 + 28);
  v12 = 0;
  Event = (struct _KEVENT *)(a1 + 64);
  KeWaitForSingleObject((PVOID)(a1 + 64), 0, 0, 0, 0);
  if ( v4 )
    v3 += *(_DWORD *)v4;
  if ( v3 < 0x3FFFFFFD && (v5 = ExAllocatePoolWithTag(PagedPool, 4 * v3 + 8, DebugMemoryTag)) != 0 )
  {
    *(_DWORD *)v5 = 0;
    if ( v4 )
    {
      v13 = 0;
      if ( *(_DWORD *)v4 > 0u )
      {
        v6 = (int)((char *)v5 + 4);
        do
        {
          *(_DWORD *)v6 = *(_DWORD *)((_BYTE *)v4 - (_BYTE *)v5 + v6);
          ++*(_DWORD *)v5;
          ++v13;
          v6 += 4;
        }
        while ( v13 < *(_DWORD *)v4 );
      }
      ExFreePoolWithTag(v4, 0);
    }
    v7 = v2 + 772;
    v8 = 16;
    do
    {
      v9 = *(_DWORD *)v7;
      if ( *(_DWORD *)v7 && *(_DWORD *)(v7 - 12) )
      {
        *(_BYTE *)(v7 - 7) = 1;
        *((_DWORD *)v5 + *(_DWORD *)v5 + 1) = v9;
        ObfReferenceObject(*((PVOID *)v5 + (*(_DWORD *)v5)++ + 1));
      }
      else
      {
        *(_BYTE *)(v7 - 7) = 0;
      }
      v7 += 152;
      --v8;
    }
    while ( v8 );
    *(_DWORD *)(a2 + 28) = v5;
  }
  else
  {
    v12 = -1073741670;
  }
  KeSetEvent(Event, 0, 0);
  return v12;
}

//----- (000149D8) --------------------------------------------------------
LONG __stdcall RemoveDevice(int a1, void *a2)
{
  void *v2; // esi@1
  void *v3; // eax@2
  void *v4; // eax@4
  PVOID *v5; // edi@7
  int v6; // ecx@11
  int v7; // edi@12
  void *v9; // [sp+18h] [bp+Ch]@6

  KeWaitForSingleObject((PVOID)(a1 + 64), 0, 0, 0, 0);
  v2 = a2;
  if ( !*((_BYTE *)a2 + 141) )
  {
    v3 = (void *)*((_DWORD *)a2 + 14);
    if ( v3 )
    {
      ExFreePoolWithTag(v3, 0);
      *((_DWORD *)a2 + 14) = 0;
    }
    v4 = (void *)*((_DWORD *)a2 + 33);
    if ( v4 )
    {
      ExFreePoolWithTag(v4, 0);
      *((_DWORD *)a2 + 33) = 0;
    }
    v9 = 0;
    if ( *((_DWORD *)v2 + 15) > 0 )
    {
      v5 = (PVOID *)((char *)v2 + 64);
      do
      {
        if ( *v5 )
        {
          ExFreePoolWithTag(*v5, 0);
          *v5 = 0;
        }
        v9 = (char *)v9 + 1;
        ++v5;
      }
      while ( (signed int)v9 < *((_DWORD *)v2 + 15) );
    }
    v6 = *((_DWORD *)v2 + 37);
    if ( v6 )
    {
      **(_DWORD **)(v6 + 40) = 1329877112;
      IoDeleteDevice(*((PDEVICE_OBJECT *)v2 + 37));
      v7 = a1;
      --*(_DWORD *)(v7 + 108);
    }
    else
    {
      v7 = a1;
    }
    memset(v2, 0, 0x98u);
    --*(_DWORD *)(v7 + 104);
  }
  return KeSetEvent((PRKEVENT)(a1 + 64), 0, 0);
}

//----- (00014AA8) --------------------------------------------------------
NTSTATUS __stdcall CreateStaticDevice(int a1)
{
  int v1; // esi@1
  int v2; // ebx@1
  PVOID v3; // eax@1
  int v4; // esi@2
  PVOID v5; // eax@3
  NTSTATUS result; // eax@4
  void *v7; // eax@5
  void *v8; // eax@7
  signed int v9; // [sp+Ch] [bp-4h]@2

  v1 = a1;
  v2 = a1 + 624;
  memset((void *)(a1 + 624), 0, 0x98u);
  *(_BYTE *)(v2 + 140) = 1;
  *(_DWORD *)(v2 + 136) = 1;
  *(_BYTE *)(v2 + 142) = 1;
  ++*(_DWORD *)(v1 + 104);
  ++*(_DWORD *)(v1 + 108);
  *(_DWORD *)v2 = 0;
  qmemcpy((void *)(a1 + 628), L"Incoming IRCOMM", 0x20u);
  v3 = ExAllocatePoolWithTag(PagedPool, 0x20u, DebugMemoryTag);
  *(_DWORD *)(v2 + 132) = v3;
  if ( v3
    && (qmemcpy(v3, L"Incoming IRCOMM", 0x20u),
        v5 = ExAllocatePoolWithTag(PagedPool, 0x16u, DebugMemoryTag),
        (*(_DWORD *)(a1 + 680) = v5) != 0) )
  {
    qmemcpy(v5, L"IR_NULL_IN", 0x16u);
    v4 = a1;
    result = CreatePdo(*(PDEVICE_OBJECT *)(a1 + 100), v2);
    v9 = result;
    if ( result >= 0 )
      return result;
  }
  else
  {
    v4 = a1;
    v9 = -1073741801;
  }
  v7 = *(void **)(a1 + 756);
  if ( v7 )
  {
    ExFreePoolWithTag(v7, 0);
    *(_DWORD *)(a1 + 756) = 0;
  }
  v8 = *(void **)(a1 + 680);
  if ( v8 )
  {
    ExFreePoolWithTag(v8, 0);
    *(_DWORD *)(a1 + 680) = 0;
  }
  *(_DWORD *)v2 = 0;
  --*(_DWORD *)(v4 + 104);
  --*(_DWORD *)(v4 + 108);
  return v9;
}
// 152D0: using guessed type wchar_t aIr_null_in[11];
// 152E6: using guessed type wchar_t aIncomingIrcomm[16];

//----- (00014BA6) --------------------------------------------------------
void __stdcall CloseEnumObject(PVOID P)
{
  int v1; // esi@1
  char *v2; // edi@3
  PVOID Pa; // [sp+10h] [bp+8h]@3

  v1 = (int)P;
  KeSetEvent((PRKEVENT)((char *)P + 4), 0, 0);
  KeWaitForSingleObject(*(PVOID *)P, 0, 0, 0, 0);
  ObfDereferenceObject(*(PVOID *)P);
  if ( *((_DWORD *)P + 20) )
    ZwClose(*((HANDLE *)P + 20));
  v2 = (char *)P + 765;
  Pa = (PVOID)16;
  do
  {
    if ( *(v2 - 1) )
    {
      *v2 = 0;
      RemoveDevice(v1, v2 - 141);
    }
    v2 += 152;
    Pa = (char *)Pa - 1;
  }
  while ( Pa );
  if ( *(_DWORD *)(v1 + 96) )
  {
    ZwClose(*(HANDLE *)(v1 + 96));
    *(_DWORD *)(v1 + 96) = 0;
  }
  ExFreePoolWithTag((PVOID)v1, 0);
}

//----- (00014C32) --------------------------------------------------------
signed int __stdcall DoIasQueries(int a1)
{
  int v1; // ST00_4@3
  int v2; // eax@8
  int v3; // edi@9
  int v4; // eax@14
  int v5; // edi@15
  signed int result; // eax@17
  void *v7; // eax@18
  PVOID *v8; // esi@21
  int v9; // [sp+Ch] [bp-20h]@20
  int v10; // [sp+10h] [bp-1Ch]@3
  char pszDest; // [sp+14h] [bp-18h]@9

  IrdaIASStringQuery(*(_DWORD *)a1, "PnP", "Name", a1 + 132);
  if ( IrdaIASStringQuery(*(_DWORD *)a1, "PnP", "DeviceID", a1 + 56) >= 0 )
    FixupDeviceId(*(_DWORD *)(a1 + 56));
  v1 = *(_DWORD *)a1;
  *(_DWORD *)(a1 + 60) = 0;
  if ( IrdaIASIntegerQuery(v1, "PnP", "CompCnt", (int)&v10) >= 0 )
  {
    if ( v10 <= 16 )
    {
      if ( v10 < 0 )
        v10 = 0;
    }
    else
    {
      v10 = 16;
    }
    v2 = 0;
    if ( v10 > 0 )
    {
      do
      {
        v3 = v2 + 1;
        RtlStringCbPrintfA(&pszDest, 0x14u, "Comp#%02d", v2 + 1);
        if ( IrdaIASStringQuery(*(_DWORD *)a1, "PnP", &pszDest, a1 + 4 * *(_DWORD *)(a1 + 60) + 64) >= 0 )
          FixupDeviceId(*(_DWORD *)(a1 + 4 * (*(_DWORD *)(a1 + 60))++ + 64));
        v2 = v3;
      }
      while ( v3 < v10 );
    }
  }
  if ( *(_BYTE *)(a1 + 144) )
  {
    if ( !*(_BYTE *)(a1 + 143) )
    {
      *(_DWORD *)(a1 + 4 * *(_DWORD *)(a1 + 60) + 64) = ExAllocatePoolWithTag(PagedPool, 0x10u, DebugMemoryTag);
      v4 = a1 + 4 * *(_DWORD *)(a1 + 60) + 64;
      if ( *(_DWORD *)v4 )
      {
        v5 = *(_DWORD *)v4;
        *(_DWORD *)v5 = *(_DWORD *)L"PNPC103";
        v5 += 4;
        *(_DWORD *)v5 = *(_DWORD *)L"\u4e00\u5000\u4300\u3100\u3000\u3300";
        v5 += 4;
        *(_DWORD *)v5 = *(_DWORD *)L"NPC103";
        *(_DWORD *)(v5 + 4) = *(_DWORD *)L"\u5000\u4300\u3100\u3000\u3300";
        ++*(_DWORD *)(a1 + 60);
      }
    }
  }
  if ( *(_DWORD *)(a1 + 56) )
  {
    result = 0;
  }
  else
  {
    v7 = *(void **)(a1 + 132);
    if ( v7 )
    {
      ExFreePoolWithTag(v7, 0);
      *(_DWORD *)(a1 + 132) = 0;
    }
    v9 = 0;
    if ( *(_DWORD *)(a1 + 60) > 0 )
    {
      v8 = (PVOID *)(a1 + 64);
      do
      {
        if ( *v8 )
        {
          ExFreePoolWithTag(*v8, 0);
          *v8 = 0;
        }
        ++v9;
        ++v8;
      }
      while ( v9 < *(_DWORD *)(a1 + 60) );
    }
    result = -1073741823;
  }
  return result;
}
// 15306: using guessed type wchar_t aPnpc103[8];

//----- (00014DA6) --------------------------------------------------------
NTSTATUS __stdcall EnumIrda(int a1)
{
  int v1; // eax@1
  signed int v2; // edx@1
  signed int v3; // esi@8
  unsigned int v4; // ebx@8
  int v5; // eax@11
  int v6; // ebx@15
  int v7; // esi@15
  char v8; // al@20
  int v9; // ebx@23
  void *v10; // eax@23
  void *v11; // eax@25
  PVOID *v12; // ebx@28
  wchar_t *v13; // eax@40
  int v14; // eax@42
  __int16 v15; // dx@43
  wchar_t *v16; // eax@44
  void *v17; // eax@48
  void *v18; // eax@50
  PVOID *v19; // ebx@53
  int v20; // esi@60
  signed int v21; // ebx@60
  NTSTATUS v23; // [sp+4h] [bp-4Ch]@0
  unsigned int v24; // [sp+8h] [bp-48h]@6
  size_t cbDest; // [sp+Ch] [bp-44h]@8
  size_t cbDesta; // [sp+Ch] [bp-44h]@44
  int v27; // [sp+10h] [bp-40h]@7
  int v28; // [sp+14h] [bp-3Ch]@8
  int v29; // [sp+14h] [bp-3Ch]@27
  int v30; // [sp+14h] [bp-3Ch]@52
  char v31; // [sp+1Bh] [bp-35h]@1
  unsigned __int16 v32[24]; // [sp+1Ch] [bp-34h]@10

  v31 = 0;
  v1 = a1 + 760;
  v2 = 16;
  do
  {
    if ( !*(_BYTE *)(v1 + 6) && *(_DWORD *)v1 )
      --*(_DWORD *)v1;
    v1 += 152;
    --v2;
  }
  while ( v2 );
  v24 = 0;
  if ( *(_DWORD *)(a1 + 112) <= 0u )
    goto LABEL_60;
  v27 = a1 + 116;
  do
  {
    cbDest = *(_DWORD *)v27;
    v3 = -1;
    v4 = 0;
    v28 = a1 + 628;
    while ( 1 )
    {
      if ( !*(_BYTE *)(v28 + 136) )
      {
        if ( v3 == -1 )
          v3 = v4;
        goto LABEL_35;
      }
      DeviceNameFromDeviceInfo(v27, v32, 24);
      if ( !wcscmp(v32, (const unsigned __int16 *)v28) )
        break;
LABEL_35:
      v28 += 152;
      ++v4;
      if ( v4 >= 0x10 )
        goto LABEL_13;
    }
    *(_DWORD *)(152 * (v4 + 5) + a1) = 1;
    v5 = 152 * v4 + a1 + 624;
    if ( cbDest != *(_DWORD *)v5 )
      *(_DWORD *)v5 = *(_DWORD *)v27;
LABEL_13:
    if ( v4 >= 0x10 && v3 != -1 )
    {
      v6 = 152 * v3 + a1;
      v7 = v6 + 624;
      memset((void *)(v6 + 624), 0, 0x98u);
      ++*(_DWORD *)(a1 + 104);
      *(_DWORD *)(v6 + 624) = cbDest;
      *(_BYTE *)(v6 + 764) = 1;
      *(_DWORD *)(v6 + 760) = 1;
      *(_BYTE *)(v6 + 676) = *(_BYTE *)(v27 + 26);
      *(_BYTE *)(v6 + 677) = *(_BYTE *)(v27 + 27);
      DeviceNameFromDeviceInfo(v27, (WCHAR *)(v6 + 628), 24);
      if ( *(_BYTE *)(v27 + 26) & 8 )
        *(_BYTE *)(v6 + 767) = 1;
      if ( *(_BYTE *)(v27 + 26) & 0x10 && *(_BYTE *)(v27 + 27) & 4 )
        *(_BYTE *)(v6 + 768) = 1;
      v8 = *(_BYTE *)(v27 + 26);
      if ( v8 & 1 )
      {
        v23 = DoIasQueries(v6 + 624);
        if ( v23 < 0 )
        {
          *(_DWORD *)(v6 + 772) = 0;
          goto LABEL_59;
        }
        v23 = CreatePdo(*(PDEVICE_OBJECT *)(a1 + 100), v6 + 624);
        if ( v23 < 0 )
        {
          v9 = v6 + 756;
          v10 = *(void **)(v7 + 132);
          if ( v10 )
          {
            ExFreePoolWithTag(v10, 0);
            *(_DWORD *)v9 = 0;
          }
          v11 = *(void **)(v7 + 56);
          if ( v11 )
          {
            ExFreePoolWithTag(v11, 0);
            *(_DWORD *)(v7 + 56) = 0;
          }
          v29 = 0;
          if ( *(_DWORD *)(v7 + 60) > 0 )
          {
            v12 = (PVOID *)(v7 + 64);
            do
            {
              if ( *v12 )
              {
                ExFreePoolWithTag(*v12, 0);
                *v12 = 0;
              }
              ++v29;
              ++v12;
            }
            while ( v29 < *(_DWORD *)(v7 + 60) );
          }
          goto LABEL_59;
        }
LABEL_58:
        ++*(_DWORD *)(a1 + 108);
        v31 = 1;
        goto LABEL_59;
      }
      if ( v8 & 0x10 && *(_BYTE *)(v27 + 27) & 4 )
      {
        v13 = (wchar_t *)ExAllocatePoolWithTag(PagedPool, 0x10u, DebugMemoryTag);
        *(_DWORD *)(v6 + 680) = v13;
        if ( v13 )
          RtlStringCbCopyW(v13, 0x10u, L"PNPC104");
        v14 = v6 + 628;
        do
        {
          v15 = *(_WORD *)v14;
          v14 += 2;
        }
        while ( v15 );
        cbDesta = 2 * ((v14 - (v6 + 630)) >> 1) + 2;
        v16 = (wchar_t *)ExAllocatePoolWithTag(0, cbDesta, DebugMemoryTag);
        *(_DWORD *)(v6 + 756) = v16;
        if ( v16 )
          RtlStringCbCopyW(v16, cbDesta, (const wchar_t *)(v6 + 628));
        if ( *(_DWORD *)(v6 + 680) )
        {
          v23 = CreatePdo(*(PDEVICE_OBJECT *)(a1 + 100), v7);
          if ( v23 >= 0 )
            goto LABEL_58;
          v17 = *(void **)(v6 + 756);
          if ( v17 )
          {
            ExFreePoolWithTag(v17, 0);
            *(_DWORD *)(v6 + 756) = 0;
          }
          v18 = *(void **)(v6 + 680);
          if ( v18 )
          {
            ExFreePoolWithTag(v18, 0);
            *(_DWORD *)(v6 + 680) = 0;
          }
          v30 = 0;
          if ( *(_DWORD *)(v6 + 684) > 0 )
          {
            v19 = (PVOID *)(v6 + 688);
            do
            {
              if ( *v19 )
              {
                ExFreePoolWithTag(*v19, 0);
                *v19 = 0;
              }
              ++v30;
              ++v19;
            }
            while ( v30 < *(_DWORD *)(v7 + 60) );
          }
        }
      }
    }
LABEL_59:
    ++v24;
    v27 += 29;
  }
  while ( v24 < *(_DWORD *)(a1 + 112) );
LABEL_60:
  v20 = a1 + 760;
  v21 = 16;
  do
  {
    if ( *(_BYTE *)(v20 + 4) && !*(_DWORD *)v20 )
    {
      if ( *(_DWORD *)(v20 + 12) )
      {
        v31 = 1;
      }
      else
      {
        memset((void *)(v20 - 136), 0, 0x98u);
        --*(_DWORD *)(a1 + 104);
      }
    }
    v20 += 152;
    --v21;
  }
  while ( v21 );
  if ( v31 )
    IoInvalidateDeviceRelations(*(PDEVICE_OBJECT *)(*(_DWORD *)(*(_DWORD *)(a1 + 100) + 40) + 8), 0);
  return v23;
}

//----- (00015144) --------------------------------------------------------
void __stdcall WorkerThread(PVOID StartContext)
{
  int v1; // esi@1
  struct _KEVENT *v2; // ST1C_4@1
  NTSTATUS v3; // eax@2
  int v4; // eax@3
  int v5; // edi@8
  void *v6; // edi@11
  void *v7; // [sp-14h] [bp-30h]@6
  void *v8; // [sp-10h] [bp-2Ch]@6
  struct _IO_STATUS_BLOCK *v9; // [sp-Ch] [bp-28h]@6
  void *v10; // [sp-8h] [bp-24h]@6
  PVOID Object; // [sp+Ch] [bp-10h]@1
  int v12; // [sp+10h] [bp-Ch]@1
  int v13; // [sp+14h] [bp-8h]@1
  char v14; // [sp+1Bh] [bp-1h]@1
  PVOID StartContexta; // [sp+24h] [bp+8h]@1

  v1 = (int)StartContext;
  v2 = (struct _KEVENT *)*((_DWORD *)StartContext + 21);
  v14 = 0;
  KeClearEvent(v2);
  v13 = *((_DWORD *)StartContext + 21);
  Object = (char *)StartContext + 4;
  StartContexta = (char *)StartContext + 24;
  v12 = v1 + 24;
  KeSetTimer((PKTIMER)(v1 + 24), (LARGE_INTEGER)-100000000i64, 0);
  do
  {
    v3 = KeWaitForMultipleObjects(3u, &Object, WaitAny, 0, 0, 0, 0, 0);
    if ( v3 )
    {
      v4 = v3 - 1;
      if ( v4 )
      {
        if ( v4 != 1 )
          continue;
        KeResetEvent(*(PRKEVENT *)(v1 + 84));
        if ( !*(_DWORD *)(v1 + 88) )
        {
          KeWaitForSingleObject((PVOID)(v1 + 64), 0, 0, 0, 0);
          EnumIrda(v1);
          KeSetEvent((PRKEVENT)(v1 + 64), 0, 0);
          v10 = (void *)(v1 + 112);
          v9 = (struct _IO_STATUS_BLOCK *)(v1 + 88);
          v8 = *(void **)(v1 + 80);
          v7 = *(void **)(v1 + 96);
LABEL_7:
          IrdaLazyDiscoverDevices(v7, v8, v9, v10, 0x200u);
          continue;
        }
      }
      else
      {
        v5 = v1 + 96;
        if ( !*(_DWORD *)(v1 + 96) && IrdaOpenControlChannel((PHANDLE)(v1 + 96)) < 0 )
          *(_DWORD *)v5 = 0;
        v6 = *(void **)v5;
        if ( v6 )
        {
          v10 = (void *)(v1 + 112);
          v9 = (struct _IO_STATUS_BLOCK *)(v1 + 88);
          v8 = *(void **)(v1 + 80);
          v7 = v6;
          goto LABEL_7;
        }
      }
      KeSetTimer((PKTIMER)StartContexta, (LARGE_INTEGER)-100000000i64, 0);
    }
    else
    {
      v14 = 1;
    }
  }
  while ( !v14 );
  KeCancelTimer((PKTIMER)StartContexta);
  PsTerminateSystemThread(0);
}

//----- (00016006) --------------------------------------------------------
NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
  USHORT v2; // ax@1
  NTSTATUS result; // eax@2
  PVOID v4; // eax@3
  struct _RTL_QUERY_REGISTRY_TABLE QueryTable; // [sp+8h] [bp-7Ch]@4
  int v6; // [sp+28h] [bp-5Ch]@4
  int v7; // [sp+2Ch] [bp-58h]@4
  int *v8; // [sp+30h] [bp-54h]@4
  int v9; // [sp+34h] [bp-50h]@4
  int *v10; // [sp+38h] [bp-4Ch]@4
  int v11; // [sp+3Ch] [bp-48h]@4
  int v12; // [sp+44h] [bp-40h]@4
  int v13; // [sp+48h] [bp-3Ch]@4
  int *v14; // [sp+4Ch] [bp-38h]@4
  int v15; // [sp+50h] [bp-34h]@4
  int *v16; // [sp+54h] [bp-30h]@4
  int v17; // [sp+58h] [bp-2Ch]@4
  int v18; // [sp+78h] [bp-Ch]@1
  int v19; // [sp+7Ch] [bp-8h]@1
  int v20; // [sp+80h] [bp-4h]@1

  v2 = RegistryPath->Length;
  v20 = 0;
  v18 = 0;
  v19 = 0;
  if ( v2 < 0xFFFDu
    && (LOWORD(DriverEntryRegPath) = v2,
        HIWORD(DriverEntryRegPath) = v2 + 2,
        v4 = ExAllocatePoolWithTag(PagedPool, (unsigned __int16)(v2 + 2), DebugMemoryTag),
        (Path = v4) != 0) )
  {
    memcpy(v4, RegistryPath->Buffer, RegistryPath->Length);
    *((_WORD *)Path + ((unsigned int)RegistryPath->Length >> 1)) = 0;
    memset(&QueryTable, 0, 0x70u);
    QueryTable.EntryContext = &v19;
    QueryTable.DefaultType = 4;
    QueryTable.DefaultData = &v20;
    QueryTable.DefaultLength = 4;
    v9 = 4;
    v11 = 4;
    v15 = 4;
    v17 = 4;
    v8 = &v18;
    QueryTable.Flags = 32;
    v6 = 32;
    v12 = 32;
    QueryTable.Name = L"BreakOnEntry";
    v7 = (int)L"DebugFlags";
    v10 = &v20;
    v13 = (int)L"EnumStaticDevice";
    v14 = &EnumStaticDevice;
    v16 = &v20;
    if ( RtlQueryRegistryValues(0x80000000, (PCWSTR)Path, &QueryTable, 0, 0) < 0 )
      v19 = 0;
    if ( v19 )
      __debugbreak();
    DriverObject->DriverExtension->AddDevice = (PDRIVER_ADD_DEVICE)IrEnumAddDevice;
    DriverObject->DriverUnload = (PDRIVER_UNLOAD)IrEnumUnload;
    memset32(DriverObject->MajorFunction, (int)UnHandledDispatch, 0x1Cu);
    DriverObject->MajorFunction[27] = (PDRIVER_DISPATCH)IrEnumPnP;
    DriverObject->MajorFunction[22] = (PDRIVER_DISPATCH)IrEnumPower;
    DriverObject->MajorFunction[23] = (PDRIVER_DISPATCH)IrEnumWmi;
    PagedCodeSectionHandle = (int)MmLockPagableDataSection(IrEnumUnload);
    MmUnlockPagableImageSection((PVOID)PagedCodeSectionHandle);
    result = 0;
  }
  else
  {
    result = -1073741670;
  }
  return result;
}
// 13010: using guessed type int EnumStaticDevice;
// 13018: using guessed type int DriverEntryRegPath;
// 13020: using guessed type int PagedCodeSectionHandle;
// 161B8: using guessed type wchar_t aEnumstaticdevi[17];
// 161DA: using guessed type wchar_t aDebugflags[11];
// 161F0: using guessed type wchar_t aBreakonentry[13];

//----- (0001616F) --------------------------------------------------------
void __cdecl __security_init_cookie()
{
  ULONG v0; // eax@1

  v0 = __security_cookie;
  if ( !__security_cookie || __security_cookie == -1153374642 )
  {
    v0 = (unsigned int)&__security_cookie ^ _KeTickCount.LowPart;
    __security_cookie = (unsigned int)&__security_cookie ^ _KeTickCount.LowPart;
    if ( &__security_cookie == (ULONG_PTR *)_KeTickCount.LowPart )
    {
      v0 = -1153374642;
      __security_cookie = -1153374642;
    }
  }
  __security_cookie_complement = ~v0;
}

// ALL OK, 32 function(s) have been successfully decompiled
